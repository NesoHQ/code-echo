<?xml version="1.0" encoding="UTF-8"?>
<!-- This file is a merged representation of the entire codebase, combined into a single document by CodeEcho CLI. -->
<!-- The content has been processed with the following options: no processing applied -->

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure (if enabled)
4. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and CodeEcho's configuration
- Binary files are not included in this packed representation
- Files matching default ignore patterns are excluded
- Generated by CodeEcho CLI on 2025-10-14T22:13:59+06:00
</notes>

</file_summary>

<repository_info>
<repo_path>/home/sami/Workspace/nesoHQ/code-echo/codeecho-cli</repo_path>
<scan_time>2025-10-14T22:13:59+06:00</scan_time>
</repository_info>

<files>
This section contains the contents of the repository's files.

<directory_structure>
project/
  cmd/
    doc.go
    root.go
    scan.go
    version.go
  config/
    loader.go
  main.go
  output/
    streaming.go
    streaming_json.go
    streaming_markdown.go
    streaming_xml.go
    tree.go
  scanner/
    analysis.go
    filters.go
    language.go
    process.go
    streaming.go
    types.go
  types/
    output_option.go
  utils/
    format.go
    path.go
</directory_structure>

<file path="cmd/doc.go" language="go" lines="518" size="14.2 KB" extension=".go" modified="2025-10-14 16:12:20" is_text="true">
package cmd

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;
	&quot;strings&quot;
	&quot;time&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/output&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/utils&quot;
	&quot;github.com/spf13/cobra&quot;
)

var (
	docOutputFile string
	docType       string
	// NEW: Add quiet and verbose flags for doc command
	docVerbose bool
	docQuiet   bool
)

// ScanResult is an alias for scanner.ScanResult for backward compatibility
type ScanResult = scanner.ScanResult
type FileInfo = scanner.FileInfo

// docCmd represents the doc command
var docCmd = &amp;cobra.Command{
	Use:   &quot;doc [path]&quot;,
	Short: &quot;Generate documentation from repository scan&quot;,
	Long: `Generate documentation automatically from a repository scan.
This command first scans the repository and then generates different types
of documentation based on the codebase structure and content.

Supported documentation types:
‚Ä¢ readme    - Generate a comprehensive README.md
‚Ä¢ api       - Generate API documentation (for web projects)
‚Ä¢ overview  - Generate project overview documentation

Examples:
  codeecho doc .                          # Generate README
  codeecho doc . --type api               # Generate API docs
  codeecho doc . --type overview -o OVERVIEW.md
  codeecho doc . --verbose                # Show progress for each file`,
	Args: cobra.MaximumNArgs(1),
	RunE: runDoc,
}

func init() {
	rootCmd.AddCommand(docCmd)

	// Add flags
	docCmd.Flags().StringVarP(&amp;docOutputFile, &quot;output&quot;, &quot;o&quot;, &quot;&quot;, &quot;Output file (default: README.md)&quot;)
	docCmd.Flags().StringVarP(&amp;docType, &quot;type&quot;, &quot;t&quot;, &quot;readme&quot;, &quot;Documentation type: readme, api, overview&quot;)

	// NEW: Add progress flags
	docCmd.Flags().BoolVarP(&amp;docVerbose, &quot;verbose&quot;, &quot;v&quot;, false, &quot;Show detailed progress information&quot;)
	docCmd.Flags().BoolVarP(&amp;docQuiet, &quot;quiet&quot;, &quot;q&quot;, false, &quot;Suppress progress output&quot;)
}

// scanRepository uses AnalysisScanner for full repository analysis
// ENHANCED: Now supports progress callbacks
func scanRepository(path string, showProgress bool, verbose bool) (*ScanResult, error) {
	opts := scanner.ScanOptions{
		IncludeSummary:       true,
		IncludeDirectoryTree: true,
		ShowLineNumbers:      false,
		OutputParsableFormat: true,
		CompressCode:         false,
		RemoveComments:       false,
		RemoveEmptyLines:     false,
		ExcludeDirs:          []string{&quot;.git&quot;, &quot;node_modules&quot;, &quot;vendor&quot;, &quot;.vscode&quot;, &quot;.idea&quot;, &quot;target&quot;, &quot;build&quot;, &quot;dist&quot;},
		IncludeExts:          []string{&quot;.go&quot;, &quot;.js&quot;, &quot;.ts&quot;, &quot;.jsx&quot;, &quot;.tsx&quot;, &quot;.json&quot;, &quot;.md&quot;, &quot;.html&quot;, &quot;.css&quot;, &quot;.py&quot;, &quot;.java&quot;, &quot;.cpp&quot;, &quot;.c&quot;, &quot;.h&quot;, &quot;.rs&quot;, &quot;.rb&quot;, &quot;.php&quot;, &quot;.yml&quot;, &quot;.yaml&quot;, &quot;.toml&quot;, &quot;.xml&quot;},
		IncludeContent:       true, // Doc needs content for analysis
	}

	// Use analysis scanner (not streaming) for full in-memory analysis
	analysisScanner := scanner.NewAnalysisScanner(path, opts)

	// NEW: Add progress callback if requested
	if showProgress {
		analysisScanner.SetProgressCallback(func(progress scanner.ScanProgress) {
			if verbose {
				// Verbose: Show every file
				fmt.Printf(&quot;  [%s] %s (%d/%d files)\n&quot;,
					progress.Phase,
					progress.CurrentFile,
					progress.ProcessedFiles,
					progress.TotalFiles)
			} else {
				// Normal: Single updating line
				bar := utils.CreateProgressBar(progress.ProcessedFiles, progress.TotalFiles, 20)

				// Truncate filename if too long
				displayFile := progress.CurrentFile
				if len(displayFile) &gt; 30 {
					displayFile = &quot;...&quot; + displayFile[len(displayFile)-27:]
				}

				fmt.Printf(&quot;\r  %s %s&quot;, bar, displayFile)
			}
		})
	}

	return analysisScanner.Scan()
}

func generateDirectoryTree(files []FileInfo) string {
	return output.GenerateDirectoryTree(files)
}

func formatBytes(bytes int64) string {
	return utils.FormatBytes(bytes)
}

func runDoc(cmd *cobra.Command, args []string) error {
	startTime := time.Now()

	// Determine target path
	targetPath := &quot;.&quot;
	if len(args) &gt; 0 {
		targetPath = args[0]
	}

	// Validate path exists
	if _, err := os.Stat(targetPath); os.IsNotExist(err) {
		return fmt.Errorf(&quot;path does not exist: %s&quot;, targetPath)
	}

	// Get absolute path
	absPath, err := filepath.Abs(targetPath)
	if err != nil {
		return fmt.Errorf(&quot;failed to get absolute path: %w&quot;, err)
	}

	if !docQuiet {
		fmt.Printf(&quot;üìö Generating %s documentation for %s...\n&quot;, docType, absPath)
	}

	// NEW: Use progress-aware scan
	result, err := scanRepository(absPath, !docQuiet, docVerbose)

	// Clear progress line if it was shown
	if !docQuiet &amp;&amp; !docVerbose {
		fmt.Print(&quot;\r\033[K&quot;) // Clear current line
	}

	if err != nil {
		return fmt.Errorf(&quot;scan failed: %w&quot;, err)
	}

	// Generate documentation based on type
	if !docQuiet {
		fmt.Printf(&quot;‚úçÔ∏è  Generating documentation...\n&quot;)
	}

	var doc string
	switch strings.ToLower(docType) {
	case &quot;readme&quot;:
		doc, err = generateReadmeDoc(result)
	case &quot;api&quot;:
		doc, err = generateAPIDoc(result)
	case &quot;overview&quot;:
		doc, err = generateOverviewDoc(result)
	default:
		return fmt.Errorf(&quot;unsupported documentation type: %s (supported: readme, api, overview)&quot;, docType)
	}

	if err != nil {
		return fmt.Errorf(&quot;failed to generate documentation: %w&quot;, err)
	}

	// Determine output file
	outputFile := docOutputFile
	if outputFile == &quot;&quot; {
		switch docType {
		case &quot;readme&quot;:
			outputFile = &quot;README.md&quot;
		case &quot;api&quot;:
			outputFile = &quot;API.md&quot;
		case &quot;overview&quot;:
			outputFile = &quot;OVERVIEW.md&quot;
		}
	}

	// Write documentation
	err = os.WriteFile(outputFile, []byte(doc), 0644)
	if err != nil {
		return fmt.Errorf(&quot;failed to write documentation file: %w&quot;, err)
	}

	duration := time.Since(startTime)

	// NEW: Enhanced summary
	if !docQuiet {
		fmt.Printf(&quot;\n‚úÖ Documentation written to %s\n&quot;, outputFile)
		fmt.Printf(&quot;üìä Summary:\n&quot;)
		fmt.Printf(&quot;  ‚îú‚îÄ Files analyzed: %d\n&quot;, result.TotalFiles)
		fmt.Printf(&quot;  ‚îú‚îÄ Total size: %s\n&quot;, utils.FormatBytes(result.TotalSize))
		fmt.Printf(&quot;  ‚îú‚îÄ Languages: %d types\n&quot;, len(result.LanguageCounts))
		fmt.Printf(&quot;  ‚îî‚îÄ Duration: %s\n&quot;, utils.FormatDuration(duration))
		fmt.Println()
	}

	return nil
}

func generateReadmeDoc(result *ScanResult) (string, error) {
	var builder strings.Builder

	// Extract project name from path
	projectName := filepath.Base(result.RepoPath)

	// Header
	builder.WriteString(fmt.Sprintf(&quot;# %s\n\n&quot;, strings.Title(projectName)))
	builder.WriteString(&quot;Generated documentation by CodeEcho\n\n&quot;)

	// Project Overview
	builder.WriteString(&quot;## Overview\n\n&quot;)
	builder.WriteString(&quot;This project contains &quot;)
	builder.WriteString(fmt.Sprintf(&quot;%d files &quot;, result.TotalFiles))
	builder.WriteString(fmt.Sprintf(&quot;with a total size of %s.\n\n&quot;, formatBytes(result.TotalSize)))

	// Technology Stack
	builder.WriteString(&quot;## Technology Stack\n\n&quot;)
	languages := analyzeTechStack(result.Files)
	for lang, count := range languages {
		builder.WriteString(fmt.Sprintf(&quot;- **%s**: %d files\n&quot;, lang, count))
	}
	builder.WriteString(&quot;\n&quot;)

	// Project Structure
	builder.WriteString(&quot;## Project Structure\n\n&quot;)
	builder.WriteString(&quot;```\n&quot;)
	builder.WriteString(generateDirectoryTree(result.Files))
	builder.WriteString(&quot;```\n\n&quot;)

	// Key Files
	builder.WriteString(&quot;## Key Files\n\n&quot;)
	keyFiles := identifyKeyFiles(result.Files)
	for _, file := range keyFiles {
		builder.WriteString(fmt.Sprintf(&quot;- **%s**: %s\n&quot;, file.RelativePath, describeFile(file)))
	}
	builder.WriteString(&quot;\n&quot;)

	// Getting Started (if applicable)
	if hasConfigFiles(result.Files) {
		builder.WriteString(&quot;## Getting Started\n\n&quot;)
		builder.WriteString(generateGettingStarted(result.Files))
	}

	// Footer
	builder.WriteString(&quot;---\n\n&quot;)
	builder.WriteString(fmt.Sprintf(&quot;*Documentation generated by CodeEcho on %s*\n&quot;,
		time.Now().Format(&quot;January 2, 2006&quot;)))

	return builder.String(), nil
}

func generateAPIDoc(result *ScanResult) (string, error) {
	var builder strings.Builder

	projectName := filepath.Base(result.RepoPath)

	builder.WriteString(fmt.Sprintf(&quot;# %s API Documentation\n\n&quot;, strings.Title(projectName)))

	// Look for API-related files
	apiFiles := findAPIFiles(result.Files)
	if len(apiFiles) == 0 {
		builder.WriteString(&quot;No API endpoints detected in this project.\n\n&quot;)
		builder.WriteString(&quot;This documentation type is best suited for web applications with API endpoints.\n&quot;)
		return builder.String(), nil
	}

	builder.WriteString(&quot;## API Endpoints\n\n&quot;)

	for _, file := range apiFiles {
		builder.WriteString(fmt.Sprintf(&quot;### %s\n\n&quot;, file.RelativePath))

		// Basic analysis of the file
		if strings.Contains(strings.ToLower(file.Content), &quot;router&quot;) ||
			strings.Contains(strings.ToLower(file.Content), &quot;endpoint&quot;) ||
			strings.Contains(strings.ToLower(file.Content), &quot;handler&quot;) {
			builder.WriteString(&quot;Contains API route definitions.\n\n&quot;)
		}
	}

	return builder.String(), nil
}

func generateOverviewDoc(result *ScanResult) (string, error) {
	var builder strings.Builder

	projectName := filepath.Base(result.RepoPath)

	builder.WriteString(fmt.Sprintf(&quot;# %s - Project Overview\n\n&quot;, strings.Title(projectName)))

	// Statistics
	builder.WriteString(&quot;## Project Statistics\n\n&quot;)
	builder.WriteString(fmt.Sprintf(&quot;- **Total Files**: %d\n&quot;, result.TotalFiles))
	builder.WriteString(fmt.Sprintf(&quot;- **Total Size**: %s\n&quot;, formatBytes(result.TotalSize)))
	builder.WriteString(fmt.Sprintf(&quot;- **Last Scanned**: %s\n\n&quot;, result.ScanTime))

	// File Distribution
	builder.WriteString(&quot;## File Distribution\n\n&quot;)
	languages := analyzeTechStack(result.Files)
	for lang, count := range languages {
		percentage := float64(count) / float64(result.TotalFiles) * 100
		builder.WriteString(fmt.Sprintf(&quot;- %s: %d files (%.1f%%)\n&quot;, lang, count, percentage))
	}
	builder.WriteString(&quot;\n&quot;)

	// Directory Analysis
	builder.WriteString(&quot;## Directory Analysis\n\n&quot;)
	dirCounts := analyzeDirectories(result.Files)
	for dir, count := range dirCounts {
		if count &gt; 1 { // Only show directories with multiple files
			builder.WriteString(fmt.Sprintf(&quot;- `%s/`: %d files\n&quot;, dir, count))
		}
	}

	return builder.String(), nil
}

// Helper functions
func analyzeTechStack(files []FileInfo) map[string]int {
	languages := make(map[string]int)

	for _, file := range files {
		ext := strings.ToLower(filepath.Ext(file.RelativePath))
		switch ext {
		case &quot;.go&quot;:
			languages[&quot;Go&quot;]++
		case &quot;.js&quot;:
			languages[&quot;JavaScript&quot;]++
		case &quot;.ts&quot;:
			languages[&quot;TypeScript&quot;]++
		case &quot;.py&quot;:
			languages[&quot;Python&quot;]++
		case &quot;.java&quot;:
			languages[&quot;Java&quot;]++
		case &quot;.cpp&quot;, &quot;.cc&quot;:
			languages[&quot;C++&quot;]++
		case &quot;.c&quot;:
			languages[&quot;C&quot;]++
		case &quot;.rs&quot;:
			languages[&quot;Rust&quot;]++
		case &quot;.rb&quot;:
			languages[&quot;Ruby&quot;]++
		case &quot;.php&quot;:
			languages[&quot;PHP&quot;]++
		case &quot;.html&quot;:
			languages[&quot;HTML&quot;]++
		case &quot;.css&quot;:
			languages[&quot;CSS&quot;]++
		case &quot;.json&quot;:
			languages[&quot;JSON&quot;]++
		case &quot;.md&quot;:
			languages[&quot;Markdown&quot;]++
		case &quot;.yml&quot;, &quot;.yaml&quot;:
			languages[&quot;YAML&quot;]++
		default:
			if ext != &quot;&quot; {
				languages[&quot;Other&quot;]++
			}
		}
	}

	return languages
}

func identifyKeyFiles(files []FileInfo) []FileInfo {
	var keyFiles []FileInfo

	keyPatterns := []string{
		&quot;main.go&quot;, &quot;main.js&quot;, &quot;index.js&quot;, &quot;app.js&quot;,
		&quot;package.json&quot;, &quot;go.mod&quot;, &quot;requirements.txt&quot;,
		&quot;dockerfile&quot;, &quot;docker-compose.yml&quot;,
		&quot;readme.md&quot;, &quot;license&quot;,
	}

	for _, file := range files {
		fileName := strings.ToLower(filepath.Base(file.RelativePath))
		for _, pattern := range keyPatterns {
			if fileName == pattern {
				keyFiles = append(keyFiles, file)
				break
			}
		}
	}

	return keyFiles
}

func describeFile(file FileInfo) string {
	fileName := strings.ToLower(filepath.Base(file.RelativePath))

	descriptions := map[string]string{
		&quot;main.go&quot;:            &quot;Main application entry point&quot;,
		&quot;main.js&quot;:            &quot;Main JavaScript file&quot;,
		&quot;index.js&quot;:           &quot;Application entry point&quot;,
		&quot;package.json&quot;:       &quot;Node.js project configuration&quot;,
		&quot;go.mod&quot;:             &quot;Go module definition&quot;,
		&quot;dockerfile&quot;:         &quot;Docker container configuration&quot;,
		&quot;docker-compose.yml&quot;: &quot;Docker services configuration&quot;,
		&quot;readme.md&quot;:          &quot;Project documentation&quot;,
	}

	if desc, exists := descriptions[fileName]; exists {
		return desc
	}

	return fmt.Sprintf(&quot;Project file (%s)&quot;, formatBytes(file.Size))
}

func hasConfigFiles(files []FileInfo) bool {
	configPatterns := []string{&quot;package.json&quot;, &quot;go.mod&quot;, &quot;requirements.txt&quot;, &quot;dockerfile&quot;}

	for _, file := range files {
		fileName := strings.ToLower(filepath.Base(file.RelativePath))
		for _, pattern := range configPatterns {
			if fileName == pattern {
				return true
			}
		}
	}
	return false
}

func generateGettingStarted(files []FileInfo) string {
	var builder strings.Builder

	// Check for different project types
	hasPackageJSON := false
	hasGoMod := false
	hasDockerfile := false

	for _, file := range files {
		fileName := strings.ToLower(filepath.Base(file.RelativePath))
		switch fileName {
		case &quot;package.json&quot;:
			hasPackageJSON = true
		case &quot;go.mod&quot;:
			hasGoMod = true
		case &quot;dockerfile&quot;:
			hasDockerfile = true
		}
	}

	if hasPackageJSON {
		builder.WriteString(&quot;### Node.js Project\n&quot;)
		builder.WriteString(&quot;```bash\n&quot;)
		builder.WriteString(&quot;npm install\n&quot;)
		builder.WriteString(&quot;npm start\n&quot;)
		builder.WriteString(&quot;```\n\n&quot;)
	}

	if hasGoMod {
		builder.WriteString(&quot;### Go Project\n&quot;)
		builder.WriteString(&quot;```bash\n&quot;)
		builder.WriteString(&quot;go mod tidy\n&quot;)
		builder.WriteString(&quot;go run main.go\n&quot;)
		builder.WriteString(&quot;```\n\n&quot;)
	}

	if hasDockerfile {
		builder.WriteString(&quot;### Docker\n&quot;)
		builder.WriteString(&quot;```bash\n&quot;)
		builder.WriteString(&quot;docker build -t app .\n&quot;)
		builder.WriteString(&quot;docker run -p 8080:8080 app\n&quot;)
		builder.WriteString(&quot;```\n\n&quot;)
	}

	return builder.String()
}

func findAPIFiles(files []FileInfo) []FileInfo {
	var apiFiles []FileInfo

	apiPatterns := []string{&quot;router&quot;, &quot;route&quot;, &quot;handler&quot;, &quot;controller&quot;, &quot;api&quot;, &quot;endpoint&quot;}

	for _, file := range files {
		fileName := strings.ToLower(file.RelativePath)
		content := strings.ToLower(file.Content)

		// Check filename
		for _, pattern := range apiPatterns {
			if strings.Contains(fileName, pattern) {
				apiFiles = append(apiFiles, file)
				break
			}
		}

		// Check content for API-related keywords
		if strings.Contains(content, &quot;http.&quot;) ||
			strings.Contains(content, &quot;express&quot;) ||
			strings.Contains(content, &quot;@requestmapping&quot;) ||
			strings.Contains(content, &quot;@getmapping&quot;) {
			apiFiles = append(apiFiles, file)
		}
	}

	return apiFiles
}

func analyzeDirectories(files []FileInfo) map[string]int {
	dirCounts := make(map[string]int)

	for _, file := range files {
		dir := filepath.Dir(file.RelativePath)
		if dir != &quot;.&quot; {
			dirCounts[dir]++
		}
	}

	return dirCounts
}

</file>

<file path="cmd/root.go" language="go" lines="44" size="1.3 KB" extension=".go" modified="2025-09-28 06:03:47" is_text="true">
// cmd/root.go
package cmd

import (
	&quot;fmt&quot;
	&quot;os&quot;

	&quot;github.com/spf13/cobra&quot;
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
	Use:   &quot;codeecho&quot;,
	Short: &quot;CodeEcho - Make your repository AI-ready&quot;,
	Long: `CodeEcho is a CLI tool that scans repositories and generates AI-ready context.
It converts your entire codebase into structured formats (JSON, Markdown) that can
be easily consumed by AI tools like ChatGPT, Claude, or Gemini.

Perfect for:
‚Ä¢ Generating documentation automatically
‚Ä¢ Creating context for AI-assisted coding
‚Ä¢ Repository analysis and insights
‚Ä¢ Code reviews and refactoring guidance`,
	Version: &quot;1.0.0-beta&quot;,
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		fmt.Fprintf(os.Stderr, &quot;Error: %v\n&quot;, err)
		os.Exit(1)
	}
}

func init() {
	// Global flags can be added here
	// rootCmd.PersistentFlags().StringVar(&amp;cfgFile, &quot;config&quot;, &quot;&quot;, &quot;config file (default is $HOME/.codeecho.yaml)&quot;)

	// Cobra also supports local flags, which will only run
	// when this action is called directly.
	rootCmd.Flags().BoolP(&quot;version&quot;, &quot;v&quot;, false, &quot;Show version information&quot;)
}

</file>

<file path="cmd/scan.go" language="go" lines="584" size="17.0 KB" extension=".go" modified="2025-10-14 22:04:21" is_text="true">
package cmd

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;
	&quot;time&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/config&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/output&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/types&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/utils&quot;
	&quot;github.com/spf13/cobra&quot;
)

var (
	// Existing flags remain the same
	outputFormat         string
	outputFile           string
	includeSummary       bool
	includeDirectoryTree bool
	showLineNumbers      bool
	outputParsableFormat bool

	compressCode     bool
	removeComments   bool
	removeEmptyLines bool

	excludeDirs    []string
	includeExts    []string
	includeContent bool
	excludeContent bool

	// NEW: Progress and error flags
	verbose    bool // Show detailed progress
	quiet      bool // Suppress progress output
	strictMode bool // Fail on any error

	// NEW: Config file flag
	configFile string
)

var scanCmd = &amp;cobra.Command{
	Use:   &quot;scan [path]&quot;,
	Short: &quot;Scan repository and generate AI-ready context&quot;,
	Long: `Scan a repository and generate structured output for AI consumption.
Similar to Repomix, this command creates a single file containing your entire
codebase in a format optimized for AI tools.

Output Formats:
  xml        - Structured XML format (recommended for AI)
  json       - JSON format for programmatic use
  markdown   - Human-readable markdown format

Examples:
  codeecho scan .                              # Basic XML scan
  codeecho scan . --format json               # JSON output
	codeecho scan . --config /path/to/.codeecho.yaml
  codeecho scan . --remove-comments           # Strip comments
  codeecho scan . --compress-code             # Minify code
  codeecho scan . --no-summary                # Skip file summary
  codeecho scan . --output packed-repo.xml    # Save to file
  codeecho scan . --verbose                   # Show detailed progress
  codeecho scan . --strict                    # Fail on any error`,
	Args: cobra.MaximumNArgs(1),
	RunE: runScan,
}

func init() {
	rootCmd.AddCommand(scanCmd)

	scanCmd.Flags().StringVarP(&amp;outputFormat, &quot;format&quot;, &quot;f&quot;, &quot;xml&quot;, &quot;Output format: xml, json, markdown&quot;)
	scanCmd.Flags().StringVarP(&amp;outputFile, &quot;output&quot;, &quot;o&quot;, &quot;&quot;, &quot;Output file (default: auto-generated)&quot;)
	scanCmd.Flags().BoolVar(&amp;includeSummary, &quot;include-summary&quot;, true, &quot;Include file summary section&quot;)
	scanCmd.Flags().BoolVar(&amp;includeDirectoryTree, &quot;include-tree&quot;, true, &quot;Include directory structure&quot;)
	scanCmd.Flags().BoolVar(&amp;showLineNumbers, &quot;line-numbers&quot;, false, &quot;Show line numbers in code blocks&quot;)
	scanCmd.Flags().BoolVar(&amp;outputParsableFormat, &quot;parsable&quot;, true, &quot;Use parsable format tags&quot;)

	scanCmd.Flags().BoolVar(&amp;compressCode, &quot;compress-code&quot;, false, &quot;Remove unnecessary whitespace from code&quot;)
	scanCmd.Flags().BoolVar(&amp;removeComments, &quot;remove-comments&quot;, false, &quot;Strip comments from source files&quot;)
	scanCmd.Flags().BoolVar(&amp;removeEmptyLines, &quot;remove-empty-lines&quot;, false, &quot;Remove empty lines from files&quot;)

	scanCmd.Flags().BoolVar(&amp;includeContent, &quot;content&quot;, true, &quot;Include file contents&quot;)
	scanCmd.Flags().BoolVar(&amp;excludeContent, &quot;no-content&quot;, false, &quot;Exclude file contents (structure only)&quot;)
	scanCmd.Flags().StringSliceVar(&amp;excludeDirs, &quot;exclude-dirs&quot;,
		[]string{&quot;.git&quot;, &quot;node_modules&quot;, &quot;vendor&quot;, &quot;.vscode&quot;, &quot;.idea&quot;, &quot;target&quot;, &quot;build&quot;, &quot;dist&quot;},
		&quot;Directories to exclude&quot;)
	scanCmd.Flags().StringSliceVar(&amp;includeExts, &quot;include-exts&quot;,
		[]string{&quot;.go&quot;, &quot;.js&quot;, &quot;.ts&quot;, &quot;.jsx&quot;, &quot;.tsx&quot;, &quot;.json&quot;, &quot;.md&quot;, &quot;.html&quot;, &quot;.css&quot;, &quot;.py&quot;, &quot;.java&quot;, &quot;.cpp&quot;, &quot;.c&quot;, &quot;.h&quot;, &quot;.rs&quot;, &quot;.rb&quot;, &quot;.php&quot;, &quot;.yml&quot;, &quot;.yaml&quot;, &quot;.toml&quot;, &quot;.xml&quot;},
		&quot;File extensions to include&quot;)

	// Progress and error handling flags
	scanCmd.Flags().BoolVarP(&amp;verbose, &quot;verbose&quot;, &quot;v&quot;, false, &quot;Show detailed progress information&quot;)
	scanCmd.Flags().BoolVarP(&amp;quiet, &quot;quiet&quot;, &quot;q&quot;, false, &quot;Suppress progress output&quot;)
	scanCmd.Flags().BoolVar(&amp;strictMode, &quot;strict&quot;, false, &quot;Fail immediately on any error&quot;)

	// NEW: Config file flag
	scanCmd.Flags().StringVar(&amp;configFile, &quot;config&quot;, &quot;&quot;,
		&quot;Path to .codeecho.yaml or .codeecho.json config file&quot;)
}

// NEW: Track which CLI flags were explicitly set
// Why: Distinguish between &quot;user didn&#39;t set flag&quot; vs &quot;flag has default value&quot;
// This allows config file to provide defaults while CLI overrides them
func getCliOverrides(cmd *cobra.Command) map[string]bool {
	overrides := make(map[string]bool)

	// Check which flags were explicitly set by user
	// We only check the important ones that might conflict with config
	if cmd.Flags().Changed(&quot;format&quot;) {
		overrides[&quot;format&quot;] = true
	}
	if cmd.Flags().Changed(&quot;exclude-dirs&quot;) {
		overrides[&quot;exclude-dirs&quot;] = true
	}
	if cmd.Flags().Changed(&quot;include-exts&quot;) {
		overrides[&quot;include-exts&quot;] = true
	}
	if cmd.Flags().Changed(&quot;content&quot;) {
		overrides[&quot;include-content&quot;] = true
	}
	if cmd.Flags().Changed(&quot;no-content&quot;) {
		overrides[&quot;no-content&quot;] = true
	}
	if cmd.Flags().Changed(&quot;include-summary&quot;) {
		overrides[&quot;include-summary&quot;] = true
	}
	if cmd.Flags().Changed(&quot;include-tree&quot;) {
		overrides[&quot;include-tree&quot;] = true
	}
	if cmd.Flags().Changed(&quot;line-numbers&quot;) {
		overrides[&quot;show-line-numbers&quot;] = true
	}
	if cmd.Flags().Changed(&quot;compress-code&quot;) {
		overrides[&quot;compress-code&quot;] = true
	}
	if cmd.Flags().Changed(&quot;remove-comments&quot;) {
		overrides[&quot;remove-comments&quot;] = true
	}
	if cmd.Flags().Changed(&quot;remove-empty-lines&quot;) {
		overrides[&quot;remove-empty-lines&quot;] = true
	}

	return overrides
}

// NEW: Load and merge configuration
// Why: Centralize config logic, make it testable
func loadAndMergeConfig(targetPath string, cmd *cobra.Command) error {
	// Step 1: Determine which config file to load
	var configPath string
	var err error

	if configFile != &quot;&quot; {
		// User specified explicit config file
		configPath = configFile
	} else {
		// Auto-discover config file starting from targetPath
		configPath, err = config.FindConfigFile(targetPath)
		if err != nil {
			return fmt.Errorf(&quot;failed to search for config file: %w&quot;, err)
		}
	}

	// If no config found, that&#39;s OK - just use CLI flags
	if configPath == &quot;&quot; {
		if !quiet {
			// Mention that config could be used (informative, not an error)
			// Actually, don&#39;t spam - only show if verbose
			if verbose {
				fmt.Println(&quot;No .codeecho.yaml or .codeecho.json found, using CLI defaults&quot;)
			}
		}
		return nil
	}

	// Step 2: Load the config file
	if !quiet {
		fmt.Printf(&quot;‚öôÔ∏è  Loading config from %s\n&quot;, configPath)
	}

	cfg, err := config.LoadConfigFile(configPath)
	if err != nil {
		return fmt.Errorf(&quot;failed to load config file: %w&quot;, err)
	}

	// Step 3: Determine which flags were explicitly set on CLI
	// This is crucial for proper precedence
	cliOverrides := getCliOverrides(cmd)

	// Step 4: Merge config into our current flag values
	// Why: Apply config defaults, but respect CLI overrides
	mergeConfigIntoFlags(cfg, cliOverrides)

	if !quiet &amp;&amp; verbose {
		fmt.Println(&quot;‚úì Config merged successfully (CLI flags take precedence)&quot;)
	}

	return nil
}

// NEW: Merge config file values into global flag variables
// Why: Modify the actual flags so rest of code sees merged values
func mergeConfigIntoFlags(cfg *config.ConfigFile, cliOverrides map[string]bool) {
	// Format: handled separately in runScan
	if !cliOverrides[&quot;format&quot;] &amp;&amp; cfg.Format != &quot;&quot; {
		outputFormat = cfg.Format
	}

	// Exclude dirs: merge if not overridden
	if !cliOverrides[&quot;exclude-dirs&quot;] &amp;&amp; len(cfg.ExcludeDirs) &gt; 0 {
		excludeDirs = cfg.ExcludeDirs
	}

	// Include exts: merge if not overridden
	if !cliOverrides[&quot;include-exts&quot;] &amp;&amp; len(cfg.IncludeExts) &gt; 0 {
		includeExts = cfg.IncludeExts
	}

	// Include content: respect config if not explicitly set
	if !cliOverrides[&quot;content&quot;] &amp;&amp; !cliOverrides[&quot;no-content&quot;] {
		includeContent = cfg.IncludeContent
	}

	// Include summary
	if !cliOverrides[&quot;include-summary&quot;] {
		includeSummary = cfg.IncludeSummary
	}

	// Include tree
	if !cliOverrides[&quot;include-tree&quot;] {
		includeDirectoryTree = cfg.IncludeTree
	}

	// Show line numbers
	if !cliOverrides[&quot;show-line-numbers&quot;] &amp;&amp; cfg.ShowLineNumbers {
		showLineNumbers = cfg.ShowLineNumbers
	}

	// Processing options
	if !cliOverrides[&quot;compress-code&quot;] &amp;&amp; cfg.CompressCode {
		compressCode = cfg.CompressCode
	}

	if !cliOverrides[&quot;remove-comments&quot;] &amp;&amp; cfg.RemoveComments {
		removeComments = cfg.RemoveComments
	}

	if !cliOverrides[&quot;remove-empty-lines&quot;] &amp;&amp; cfg.RemoveEmptyLines {
		removeEmptyLines = cfg.RemoveEmptyLines
	}

	// Output file
	if outputFile == &quot;&quot; &amp;&amp; cfg.Output != &quot;&quot; {
		outputFile = cfg.Output
	}

	// Progress flags
	if !cliOverrides[&quot;verbose&quot;] &amp;&amp; cfg.OutputVerbose {
		verbose = cfg.OutputVerbose
	}

	if !cliOverrides[&quot;quiet&quot;] &amp;&amp; cfg.OutputQuiet {
		quiet = cfg.OutputQuiet
	}
}

func runScan(cmd *cobra.Command, args []string) error {
	startTime := time.Now()

	// Determine target path
	targetPath := &quot;.&quot;
	if len(args) &gt; 0 {
		targetPath = args[0]
	}

	// Validate path exists
	if _, err := os.Stat(targetPath); os.IsNotExist(err) {
		return fmt.Errorf(&quot;path does not exist: %s&quot;, targetPath)
	}

	// Get absolute path for cleaner output
	absPath, err := filepath.Abs(targetPath)
	if err != nil {
		return fmt.Errorf(&quot;failed to get absolute path: %w&quot;, err)
	}

	// NEW: Load config before proceeding with scan
	// Why: Do this early so all subsequent operations use merged config
	if err := loadAndMergeConfig(absPath, cmd); err != nil {
		// Config errors should be shown but not fatal (unless we want strict mode)
		if strictMode {
			return err
		}
		if !quiet {
			fmt.Printf(&quot;Warning: %v\n&quot;, err)
		}
	}

	if !quiet {
		fmt.Printf(&quot;üîç Scanning repository at %s...\n&quot;, absPath)
	}

	if excludeContent {
		includeContent = false
	}

	if compressCode || removeComments || removeEmptyLines {
		if !quiet {
			fmt.Println(&quot;‚öôÔ∏è  File processing enabled:&quot;)
			if compressCode {
				fmt.Println(&quot;    ‚Ä¢ Code compression&quot;)
			}
			if removeComments {
				fmt.Println(&quot;    ‚Ä¢ Comment removal&quot;)
			}
			if removeEmptyLines {
				fmt.Println(&quot;    ‚Ä¢ Empty line removal&quot;)
			}
		}
	}

	// Determine output file
	var outputFilePath string
	if outputFile != &quot;&quot; {
		outputFilePath = outputFile
	} else {
		outputOpts := types.OutputOptions{
			IncludeSummary:       includeSummary,
			IncludeDirectoryTree: includeDirectoryTree,
			ShowLineNumbers:      showLineNumbers,
			IncludeContent:       includeContent,
			RemoveComments:       removeComments,
			RemoveEmptyLines:     removeEmptyLines,
			CompressCode:         compressCode,
		}
		outputFilePath = utils.GenerateAutoFilename(absPath, outputFormat, outputOpts)
	}

	// Create output file
	outFile, err := os.Create(outputFilePath)
	if err != nil {
		return fmt.Errorf(&quot;failed to create output file: %w&quot;, err)
	}
	defer outFile.Close()

	// Create output options
	outputOpts := types.OutputOptions{
		IncludeSummary:       includeSummary,
		IncludeDirectoryTree: includeDirectoryTree,
		ShowLineNumbers:      showLineNumbers,
		IncludeContent:       includeContent,
		RemoveComments:       removeComments,
		RemoveEmptyLines:     removeEmptyLines,
		CompressCode:         compressCode,
	}

	// Create streaming writer based on format
	writer, err := output.NewStreamingWriter(outFile, outputFormat, outputOpts)
	if err != nil {
		return err
	}
	defer writer.Close()

	// Write header
	scanTime := time.Now().Format(time.RFC3339)
	if err := writer.WriteHeader(absPath, scanTime); err != nil {
		return fmt.Errorf(&quot;failed to write header: %w&quot;, err)
	}

	// Create scanner with streaming handler
	scanOpts := scanner.ScanOptions{
		IncludeSummary:       includeSummary,
		IncludeDirectoryTree: includeDirectoryTree,
		ShowLineNumbers:      showLineNumbers,
		OutputParsableFormat: outputParsableFormat,
		CompressCode:         compressCode,
		RemoveComments:       removeComments,
		RemoveEmptyLines:     removeEmptyLines,
		ExcludeDirs:          excludeDirs,
		IncludeExts:          includeExts,
		IncludeContent:       includeContent,
	}

	streamingScanner := scanner.NewStreamingScanner(absPath, scanOpts, writer.WriteFile)
	streamingScanner.SetTreeWriter(writer.WriteTree)

	// NEW: Setup progress tracking
	if !quiet {
		streamingScanner.SetProgressCallback(createProgressDisplay(verbose))
	}

	// Perform the scan
	if !quiet {
		fmt.Println(&quot;üìä Streaming scan in progress...&quot;)
	}

	stats, err := streamingScanner.Scan()

	// NEW: Check for errors in strict mode
	scanErrors := streamingScanner.GetErrors()
	if strictMode &amp;&amp; len(scanErrors) &gt; 0 {
		return fmt.Errorf(&quot;scan failed in strict mode: %d errors encountered&quot;, len(scanErrors))
	}

	if err != nil {
		return fmt.Errorf(&quot;scan failed: %w&quot;, err)
	}

	// Write footer with final statistics
	if err := writer.WriteFooter(stats); err != nil {
		return fmt.Errorf(&quot;failed to write footer: %w&quot;, err)
	}

	duration := time.Since(startTime)

	// Clear progress line
	if !quiet &amp;&amp; !verbose {
		fmt.Print(&quot;\r\033[K&quot;) // Clear current line
	}

	// NEW: Display comprehensive summary
	displayScanSummary(outputFilePath, stats, scanErrors, duration)

	return nil
}

// NEW: Create progress display function
// Why: Centralized progress handling with verbose/quiet modes
func createProgressDisplay(verbose bool) scanner.ProgressCallback {
	var lastUpdate time.Time
	startTime := time.Now()

	return func(progress scanner.ScanProgress) {
		// Throttle updates to avoid terminal spam
		// Why: Updating too fast causes flickering
		now := time.Now()
		if now.Sub(lastUpdate) &lt; 100*time.Millisecond &amp;&amp; progress.Percentage &lt; 100 {
			return
		}
		lastUpdate = now

		if verbose {
			// Verbose mode: Show every file
			elapsed := time.Since(startTime)
			eta := utils.EstimateTimeRemaining(progress.ProcessedFiles, progress.TotalFiles, elapsed)

			fmt.Printf(&quot;  [%s] %s - %s (ETA: %s)\n&quot;,
				progress.Phase,
				progress.CurrentFile,
				utils.CreateProgressBar(progress.ProcessedFiles, progress.TotalFiles, 20),
				eta,
			)
		} else {
			// Normal mode: Single updating line
			bar := utils.CreateProgressBar(progress.ProcessedFiles, progress.TotalFiles, 30)

			// Truncate filename if too long
			displayFile := progress.CurrentFile
			if len(displayFile) &gt; 40 {
				displayFile = &quot;...&quot; + displayFile[len(displayFile)-37:]
			}

			fmt.Printf(&quot;\r  %s %s&quot;, bar, displayFile)
		}
	}
}

// NEW: Display comprehensive scan summary
// Why: Users need to see what happened - success, warnings, errors
func displayScanSummary(outputPath string, stats *scanner.StreamingStats, errors []scanner.ScanError, duration time.Duration) {
	fmt.Printf(&quot;\n‚úÖ Output written to %s\n&quot;, outputPath)

	fmt.Printf(&quot;\nüìà Scan Summary:\n&quot;)
	fmt.Printf(&quot;  ‚îú‚îÄ Files processed: %d\n&quot;, stats.TotalFiles)
	fmt.Printf(&quot;  ‚îú‚îÄ Total size: %s\n&quot;, utils.FormatBytes(stats.TotalSize))
	fmt.Printf(&quot;  ‚îú‚îÄ Text files: %d\n&quot;, stats.TextFiles)
	fmt.Printf(&quot;  ‚îú‚îÄ Binary files: %d\n&quot;, stats.BinaryFiles)
	fmt.Printf(&quot;  ‚îî‚îÄ Duration: %s\n&quot;, utils.FormatDuration(duration))

	// Show language breakdown
	if len(stats.LanguageCounts) &gt; 0 {
		fmt.Printf(&quot;\nüíª Languages detected:\n&quot;)

		// Sort languages by count
		type langCount struct {
			lang  string
			count int
		}
		var langs []langCount
		for lang, count := range stats.LanguageCounts {
			langs = append(langs, langCount{lang, count})
		}

		// Simple bubble sort (good enough for small lists)
		for i := 0; i &lt; len(langs); i++ {
			for j := i + 1; j &lt; len(langs); j++ {
				if langs[j].count &gt; langs[i].count {
					langs[i], langs[j] = langs[j], langs[i]
				}
			}
		}

		// Show top 10
		maxShow := 10
		if len(langs) &lt; maxShow {
			maxShow = len(langs)
		}

		for i := 0; i &lt; maxShow; i++ {
			prefix := &quot;‚îú‚îÄ&quot;
			if i == maxShow-1 &amp;&amp; len(errors) == 0 {
				prefix = &quot;‚îî‚îÄ&quot;
			}
			percentage := float64(langs[i].count) / float64(stats.TotalFiles) * 100
			fmt.Printf(&quot;  %s %s: %d files (%.1f%%)\n&quot;, prefix, langs[i].lang, langs[i].count, percentage)
		}

		if len(langs) &gt; maxShow {
			fmt.Printf(&quot;  ‚îî‚îÄ ... and %d more\n&quot;, len(langs)-maxShow)
		}
	}

	// NEW: Display errors if any
	if len(errors) &gt; 0 {
		fmt.Printf(&quot;\n‚ö†Ô∏è  Warnings/Errors: %d issues encountered\n&quot;, len(errors))

		// Categorize errors
		readErrors := 0
		permissionErrors := 0
		otherErrors := 0

		for _, err := range errors {
			if err.Phase == &quot;read&quot; {
				readErrors++
			} else if err.Phase == &quot;scan&quot; &amp;&amp; err.Error != nil {
				// Check if it&#39;s a permission error
				if os.IsPermission(err.Error) {
					permissionErrors++
				} else {
					otherErrors++
				}
			} else {
				otherErrors++
			}
		}

		if readErrors &gt; 0 {
			fmt.Printf(&quot;  ‚îú‚îÄ Read errors: %d files couldn&#39;t be read\n&quot;, readErrors)
		}
		if permissionErrors &gt; 0 {
			fmt.Printf(&quot;  ‚îú‚îÄ Permission denied: %d files\n&quot;, permissionErrors)
		}
		if otherErrors &gt; 0 {
			fmt.Printf(&quot;  ‚îî‚îÄ Other errors: %d\n&quot;, otherErrors)
		}

		// Show first few errors if verbose or if there are only a few
		if verbose || len(errors) &lt;= 5 {
			fmt.Printf(&quot;\nüìù Error details:\n&quot;)
			maxErrors := 10
			if len(errors) &lt; maxErrors {
				maxErrors = len(errors)
			}

			for i := 0; i &lt; maxErrors; i++ {
				prefix := &quot;‚îú‚îÄ&quot;
				if i == maxErrors-1 {
					prefix = &quot;‚îî‚îÄ&quot;
				}
				fmt.Printf(&quot;  %s %s: %v\n&quot;, prefix, errors[i].Path, errors[i].Error)
			}

			if len(errors) &gt; maxErrors {
				fmt.Printf(&quot;  ‚îî‚îÄ ... and %d more errors (use --verbose to see all)\n&quot;, len(errors)-maxErrors)
			}
		} else {
			fmt.Printf(&quot;  üí° Use --verbose to see error details\n&quot;)
		}
	}

	fmt.Println() // Empty line for spacing
}

</file>

<file path="cmd/version.go" language="go" lines="31" size="709 B" extension=".go" modified="2025-09-28 06:23:34" is_text="true">
// cmd/version.go
package cmd

import (
	&quot;fmt&quot;
	&quot;runtime&quot;

	&quot;github.com/spf13/cobra&quot;
)

const (
	Version   = &quot;1.0.0-beta&quot;
	BuildDate = &quot;2025-01-27&quot;
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
	Use:   &quot;version&quot;,
	Short: &quot;Show CodeEcho version information&quot;,
	Long:  `Display version information for CodeEcho CLI tool, including build details and runtime information.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Printf(&quot;CodeEcho CLI %s\n&quot;, Version)
		fmt.Printf(&quot;Build Date: %s\n&quot;, BuildDate)
		fmt.Printf(&quot;Go Version: %s\n&quot;, runtime.Version())
		fmt.Printf(&quot;OS/Arch: %s/%s\n&quot;, runtime.GOOS, runtime.GOARCH)
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)
}

</file>

<file path="config/loader.go" language="go" lines="231" size="6.0 KB" extension=".go" modified="2025-10-14 16:11:48" is_text="true">
package config

import (
	&quot;fmt&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
	&quot;gopkg.in/yaml.v3&quot;
)

type ConfigFile struct {
	// Scanning options
	Format          string   `yaml:&quot;format&quot; json:&quot;format&quot;`
	ExcludeDirs     []string `yaml:&quot;exclude_dirs&quot; json:&quot;exclude_dirs&quot;`
	IncludeExts     []string `yaml:&quot;include_exts&quot; json:&quot;include_exts&quot;`
	IncludeContent  bool     `yaml:&quot;include_content&quot; json:&quot;include_content&quot;`
	IncludeSummary  bool     `yaml:&quot;include_summary&quot; json:&quot;include_summary&quot;`
	IncludeTree     bool     `yaml:&quot;include_tree&quot; json:&quot;include_tree&quot;`
	ShowLineNumbers bool     `yaml:&quot;show_line_numbers&quot; json:&quot;show_line_numbers&quot;`

	// Processing options
	CompressCode     bool `yaml:&quot;compress_code&quot; json:&quot;compress_code&quot;`
	RemoveComments   bool `yaml:&quot;remove_comments&quot; json:&quot;remove_comments&quot;`
	RemoveEmptyLines bool `yaml:&quot;remove_empty_lines&quot; json:&quot;remove_empty_lines&quot;`

	// Output options
	Output        string `yaml:&quot;output&quot; json:&quot;output&quot;`
	OutputQuiet   bool   `yaml:&quot;quiet&quot; json:&quot;quiet&quot;`
	OutputVerbose bool   `yaml:&quot;verbose&quot; json:&quot;verbose&quot;`

	// Presets (for future use)
	Preset string `yaml:&quot;preset&quot; json:&quot;preset&quot;`
}

// FindConfigFile looks for .codeecho.yaml or .codeecho.json in the current directory
// and up to the root of the repo
// Why: Many projects store config at repo root, but user may run from subdirectory

func FindConfigFile(startPath string) (string, error) {
	// Normalize path
	if startPath == &quot;&quot; {
		startPath = &quot;.&quot;
	}

	absPath, err := filepath.Abs(startPath)
	if err != nil {
		return &quot;&quot;, err
	}

	// Check if startPath is a file or directory
	info, err := os.Stat(absPath)
	if err != nil {
		return &quot;&quot;, err
	}

	// if it&#39;s a file, start from its directory
	if !info.IsDir() {
		absPath = filepath.Dir(absPath)
	}

	// Walk up directory tree looking for config
	// Why limit? Prevent infinite loops and excessive searching
	maxLevels := 10
	currentPath := absPath

	for i := 0; i &lt; maxLevels; i++ {
		// Check for YAML first (preferred)
		yamlPath := filepath.Join(currentPath, &quot;.codeecho.yaml&quot;)
		if _, err := os.Stat(yamlPath); err == nil {
			return yamlPath, nil
		}

		// Check for JSON as fallback
		jsonPath := filepath.Join(currentPath, &quot;.codeecho.json&quot;)
		if _, err := os.Stat(jsonPath); err == nil {
			return jsonPath, nil
		}

		// Move to parent directory
		parentPath := filepath.Dir(currentPath)
		if parentPath == currentPath {
			// Reached root directory
			break
		}
		currentPath = parentPath
	}
	return &quot;&quot;, nil // No config found (not an error)
}

// LoadConfigFile reads and parses a .codeecho.yaml or .codeecho.json file
// Why separate function? Makes it testable and reusable
func LoadConfigFile(filePath string) (*ConfigFile, error) {
	if filePath == &quot;&quot; {
		return nil, fmt.Errorf(&quot;config file path is empty&quot;)
	}

	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf(&quot;failed to read config file: %w&quot;, err)
	}

	config := &amp;ConfigFile{}

	// Determine file type by extension
	ext := filepath.Ext(filePath)
	switch ext {
	case &quot;.yaml&quot;, &quot;.yml&quot;:
		if err := yaml.Unmarshal(data, config); err != nil {
			return nil, fmt.Errorf(&quot;failed to parse YAML config: %w&quot;, err)
		}
	case &quot;.json&quot;:
		// JSON is handled by Go&#39;s encoding/json with YAML tags
		// This works because YAML is a superset of JSON
		if err := yaml.Unmarshal(data, config); err != nil {
			return nil, fmt.Errorf(&quot;failed to parse JSON config: %w&quot;, err)
		}
	default:
		return nil, fmt.Errorf(&quot;unsupported config file format: %s&quot;, ext)
	}

	return config, nil
}

// ApplyConfigToOptions merges ConfigFile values into ScanOptions
// Implements precedence: CLI flags &gt; config file &gt; defaults
// Why: Users can override config with flags
func ApplyConfigToOptions(configFile *ConfigFile, opts *scanner.ScanOptions,
	cliOverrides map[string]bool) {

	if configFile == nil {
		return
	}

	// Only apply config values if CLI flag wasn&#39;t explicitly set
	// We use a map to track which flags were provided on CLI

	if !cliOverrides[&quot;format&quot;] &amp;&amp; configFile.Format != &quot;&quot; {
		// Note: Format is handled separately in cmd/scan.go
		// This is just for reference
	}

	if !cliOverrides[&quot;exclude-dirs&quot;] &amp;&amp; len(configFile.ExcludeDirs) &gt; 0 {
		opts.ExcludeDirs = configFile.ExcludeDirs
	}

	if !cliOverrides[&quot;include-exts&quot;] &amp;&amp; len(configFile.IncludeExts) &gt; 0 {
		opts.IncludeExts = configFile.IncludeExts
	}

	if !cliOverrides[&quot;include-content&quot;] &amp;&amp; !configFile.IncludeContent {
		// Config explicitly says don&#39;t include content
		opts.IncludeContent = configFile.IncludeContent
	}

	if !cliOverrides[&quot;include-summary&quot;] {
		opts.IncludeSummary = configFile.IncludeSummary
	}

	if !cliOverrides[&quot;include-tree&quot;] {
		opts.IncludeDirectoryTree = configFile.IncludeTree
	}

	if !cliOverrides[&quot;show-line-numbers&quot;] &amp;&amp; configFile.ShowLineNumbers {
		opts.ShowLineNumbers = configFile.ShowLineNumbers
	}

	if !cliOverrides[&quot;compress-code&quot;] &amp;&amp; configFile.CompressCode {
		opts.CompressCode = configFile.CompressCode
	}

	if !cliOverrides[&quot;remove-comments&quot;] &amp;&amp; configFile.RemoveComments {
		opts.RemoveComments = configFile.RemoveComments
	}

	if !cliOverrides[&quot;remove-empty-lines&quot;] &amp;&amp; configFile.RemoveEmptyLines {
		opts.RemoveEmptyLines = configFile.RemoveEmptyLines
	}
}

// CreateDefaultConfigFile generates a template config file
// Use: `codeecho init` command (future feature)
func CreateDefaultConfigFile() string {
	return `# CodeEcho Configuration File
# Save as .codeecho.yaml in your project root

# Output format: xml, json, or markdown
format: xml

# File filtering
exclude_dirs:
  - .git
  - node_modules
  - vendor
  - dist
  - build
  - .vscode
  - .idea

include_exts:
  - .go
  - .js
  - .ts
  - .jsx
  - .tsx
  - .json
  - .md
  - .html
  - .css
  - .py

# Content options
include_content: true
include_summary: true
include_tree: true
show_line_numbers: false

# Processing options
compress_code: false
remove_comments: false
remove_empty_lines: false

# Output options
output: &quot;&quot;      # Leave empty for auto-generated filenames
quiet: false
verbose: false

# Preset profiles (future expansion)
# preset: &quot;ai-optimized&quot;  # minimal, comprehensive, ai-optimized, documentation
`
}

</file>

<file path="main.go" language="go" lines="7" size="100 B" extension=".go" modified="2025-10-14 16:14:44" is_text="true">
package main

import &quot;github.com/NesoHQ/code-echo/codeecho-cli/cmd&quot;

func main() {
	cmd.Execute()
}

</file>

<file path="output/streaming.go" language="go" lines="32" size="902 B" extension=".go" modified="2025-10-14 20:22:27" is_text="true">
package output

import (
	&quot;fmt&quot;
	&quot;io&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/types&quot;
)

type StreamingWriter interface {
	WriteHeader(repoPath string, scanTime string) error
	WriteTree(paths []string) error
	WriteFile(file *scanner.FileInfo) error
	WriteFooter(stats *scanner.StreamingStats) error
	Close() error
}

// NewStreamingWriter creates the appropriate writer based on format
// Factory pattern - returns different implementations of same interface
func NewStreamingWriter(w io.Writer, format string, opts types.OutputOptions) (StreamingWriter, error) {
	switch format {
	case &quot;xml&quot;:
		return NewStreamingXMLWriter(w, opts), nil
	case &quot;json&quot;:
		return NewStreamingJSONWriter(w, opts), nil
	case &quot;markdown&quot;, &quot;md&quot;:
		return NewStreamingMarkdownWriter(w, opts), nil
	default:
		return nil, fmt.Errorf(&quot;unsupported format: %s&quot;, format)
	}
}

</file>

<file path="output/streaming_json.go" language="go" lines="149" size="3.3 KB" extension=".go" modified="2025-10-14 20:23:45" is_text="true">
package output

import (
	&quot;bufio&quot;
	&quot;encoding/json&quot;
	&quot;fmt&quot;
	&quot;io&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/types&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/utils&quot;
)

// StreamingJSONWriter writes JSON output incrementally
type StreamingJSONWriter struct {
	writer    *bufio.Writer
	opts      types.OutputOptions
	stats     *scanner.StreamingStats
	firstFile bool // Track if this is the first file (for comma handling)
}

func NewStreamingJSONWriter(w io.Writer, opts types.OutputOptions) *StreamingJSONWriter {
	return &amp;StreamingJSONWriter{
		writer: bufio.NewWriterSize(w, 65536),
		opts:   opts,
		stats: &amp;scanner.StreamingStats{
			LanguageCounts: make(map[string]int),
		},
		firstFile: true,
	}
}

func (w *StreamingJSONWriter) WriteHeader(repoPath string, scanTime string) error {
	// Start JSON object
	if _, err := w.writer.WriteString(&quot;{\n&quot;); err != nil {
		return err
	}

	// Write repo metadata
	repoInfo := fmt.Sprintf(`  &quot;repo_path&quot;: %s,
  &quot;scan_time&quot;: %s,
  &quot;processed_by&quot;: &quot;CodeEcho CLI&quot;,
  &quot;files&quot;: [
`, jsonString(repoPath), jsonString(scanTime))

	if _, err := w.writer.WriteString(repoInfo); err != nil {
		return err
	}

	return nil
}

func (w *StreamingJSONWriter) WriteTree(paths []string) error {
	if !w.opts.IncludeDirectoryTree || len(paths) == 0 {
		return nil
	}

	// Convert paths to FileInfo structs (minimal data needed for tree)
	fileInfos := make([]scanner.FileInfo, len(paths))
	for i, path := range paths {
		fileInfos[i] = scanner.FileInfo{RelativePath: path}
	}

	tree := GenerateDirectoryTree(fileInfos)

	// Add tree field before files array
	treeField := fmt.Sprintf(`  &quot;directory_tree&quot;: %s,
`, jsonString(tree))

	if _, err := w.writer.WriteString(treeField); err != nil {
		return err
	}

	return nil
}

func (w *StreamingJSONWriter) WriteFile(file *scanner.FileInfo) error {
	// Update stats
	w.stats.TotalFiles++
	w.stats.TotalSize += file.Size

	if file.IsText {
		w.stats.TextFiles++
	} else {
		w.stats.BinaryFiles++
	}

	if file.Language != &quot;&quot; {
		w.stats.LanguageCounts[file.Language]++
	}

	// Add comma before all files except the first
	// This is why we need firstFile flag
	if !w.firstFile {
		if _, err := w.writer.WriteString(&quot;,\n&quot;); err != nil {
			return err
		}
	}
	w.firstFile = false

	// Marshal file to JSON (Go does this automatically)
	fileJSON, err := json.MarshalIndent(file, &quot;    &quot;, &quot;  &quot;)
	if err != nil {
		return err
	}

	// Write with proper indentation
	if _, err := w.writer.WriteString(&quot;    &quot;); err != nil {
		return err
	}
	if _, err := w.writer.Write(fileJSON); err != nil {
		return err
	}

	return nil
}

func (w *StreamingJSONWriter) WriteFooter(stats *scanner.StreamingStats) error {
	// Close files array
	if _, err := w.writer.WriteString(&quot;\n  ],\n&quot;); err != nil {
		return err
	}

	// Write statistics
	statsJSON := fmt.Sprintf(`  &quot;statistics&quot;: {
    &quot;total_files&quot;: %d,
    &quot;total_size&quot;: %s,
    &quot;text_files&quot;: %d,
    &quot;binary_files&quot;: %d
  }
}
`, stats.TotalFiles, jsonString(utils.FormatBytes(stats.TotalSize)), stats.TextFiles, stats.BinaryFiles)

	if _, err := w.writer.WriteString(statsJSON); err != nil {
		return err
	}

	return nil
}

func (w *StreamingJSONWriter) Close() error {
	return w.writer.Flush()
}

// jsonString properly escapes a string for JSON
func jsonString(s string) string {
	b, _ := json.Marshal(s)
	return string(b)
}

</file>

<file path="output/streaming_markdown.go" language="go" lines="161" size="3.7 KB" extension=".go" modified="2025-10-14 20:23:38" is_text="true">
package output

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;strings&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/types&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/utils&quot;
)

type StreamingMarkdownWriter struct {
	writer *bufio.Writer
	opts   types.OutputOptions
	stats  *scanner.StreamingStats
}

func NewStreamingMarkdownWriter(w io.Writer, opts types.OutputOptions) *StreamingMarkdownWriter {
	return &amp;StreamingMarkdownWriter{
		writer: bufio.NewWriterSize(w, 65536),
		opts:   opts,
		stats: &amp;scanner.StreamingStats{
			LanguageCounts: make(map[string]int),
		},
	}
}

func (w *StreamingMarkdownWriter) WriteHeader(repoPath string, scanTime string) error {
	header := fmt.Sprintf(`# CodeEcho Repository Scan

**Repository:** %s
**Scan Time:** %s

## Files

`, repoPath, scanTime)

	if _, err := w.writer.WriteString(header); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) WriteTree(paths []string) error {
	if !w.opts.IncludeDirectoryTree || len(paths) == 0 {
		return nil
	}

	// Convert paths to FileInfo structs (minimal data needed for tree)
	fileInfos := make([]scanner.FileInfo, len(paths))
	for i, path := range paths {
		fileInfos[i] = scanner.FileInfo{RelativePath: path}
	}

	tree := GenerateDirectoryTree(fileInfos)

	// Write tree section
	if _, err := w.writer.WriteString(&quot;## Directory Structure\n\n&quot;); err != nil {
		return err
	}
	if _, err := w.writer.WriteString(&quot;```\n&quot;); err != nil {
		return err
	}
	if _, err := w.writer.WriteString(tree); err != nil {
		return err
	}
	if _, err := w.writer.WriteString(&quot;```\n\n&quot;); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) WriteFile(file *scanner.FileInfo) error {
	// Update stats
	w.stats.TotalFiles++
	w.stats.TotalSize += file.Size

	if file.IsText {
		w.stats.TextFiles++
	} else {
		w.stats.BinaryFiles++
	}

	if file.Language != &quot;&quot; {
		w.stats.LanguageCounts[file.Language]++
	}

	// File header
	if _, err := w.writer.WriteString(fmt.Sprintf(&quot;### %s\n\n&quot;, file.RelativePath)); err != nil {
		return err
	}

	// Metadata
	metadata := fmt.Sprintf(&quot;**Size:** %s&quot;, file.SizeFormatted)
	if file.Language != &quot;&quot; {
		metadata += fmt.Sprintf(&quot; | **Language:** %s&quot;, file.Language)
	}
	if file.LineCount &gt; 0 {
		metadata += fmt.Sprintf(&quot; | **Lines:** %d&quot;, file.LineCount)
	}
	if file.Extension != &quot;&quot; {
		metadata += fmt.Sprintf(&quot; | **Extension:** %s&quot;, file.Extension)
	}
	metadata += fmt.Sprintf(&quot; | **Modified:** %s&quot;, file.ModTimeFormatted)
	metadata += fmt.Sprintf(&quot; | **Text File:** %t\n\n&quot;, file.IsText)

	if _, err := w.writer.WriteString(metadata); err != nil {
		return err
	}

	// Content
	if w.opts.IncludeContent &amp;&amp; file.Content != &quot;&quot; &amp;&amp; file.IsText {
		codeBlock := fmt.Sprintf(&quot;```%s\n%s\n```\n\n&quot;, strings.ToLower(file.Language), file.Content)
		if _, err := w.writer.WriteString(codeBlock); err != nil {
			return err
		}
	} else if !file.IsText {
		if _, err := w.writer.WriteString(&quot;*Binary file - content not displayed*\n\n&quot;); err != nil {
			return err
		}
	} else {
		if _, err := w.writer.WriteString(&quot;*Content not included*\n\n&quot;); err != nil {
			return err
		}
	}

	// Separator
	if _, err := w.writer.WriteString(&quot;---\n\n&quot;); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) WriteFooter(stats *scanner.StreamingStats) error {
	footer := fmt.Sprintf(`## Scan Statistics

- **Total Files:** %d
- **Total Size:** %s
- **Text Files:** %d
- **Binary Files:** %d

---

*Generated by CodeEcho CLI*
`, stats.TotalFiles, utils.FormatBytes(stats.TotalSize), stats.TextFiles, stats.BinaryFiles)

	if _, err := w.writer.WriteString(footer); err != nil {
		return err
	}

	return nil
}

func (w *StreamingMarkdownWriter) Close() error {
	return w.writer.Flush()
}

</file>

<file path="output/streaming_xml.go" language="go" lines="298" size="8.2 KB" extension=".go" modified="2025-10-14 20:23:18" is_text="true">
package output

import (
	&quot;bufio&quot;
	&quot;fmt&quot;
	&quot;io&quot;
	&quot;strings&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/types&quot;
	&quot;github.com/NesoHQ/code-echo/codeecho-cli/utils&quot;
)

// StreamingXMLWriter writes XML output incrementally
type StreamingXMLWriter struct {
	writer *bufio.Writer // Buffered writer for performance (batches small writes)
	opts   types.OutputOptions
	stats  *scanner.StreamingStats // Track stats as we go
}

// NewStreamingXMLWriter creates a new streaming XML writer
func NewStreamingXMLWriter(w io.Writer, opts types.OutputOptions) *StreamingXMLWriter {
	return &amp;StreamingXMLWriter{
		writer: bufio.NewWriterSize(w, 65536), // 64KB buffer for efficiency
		opts:   opts,
		stats: &amp;scanner.StreamingStats{
			LanguageCounts: make(map[string]int),
		},
	}
}

// WriteHeader writes the XML declaration and opening tags
func (w *StreamingXMLWriter) WriteHeader(repoPath string, scanTime string) error {
	// XML declaration
	if _, err := w.writer.WriteString(`&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;` + &quot;\n&quot;); err != nil {
		return err
	}

	// Comments explaining processing
	if _, err := w.writer.WriteString(&quot;&lt;!-- This file is a merged representation of the entire codebase, combined into a single document by CodeEcho CLI. --&gt;\n&quot;); err != nil {
		return err
	}

	if _, err := w.writer.WriteString(&quot;&lt;!-- The content has been processed with the following options: &quot;); err != nil {
		return err
	}

	var options []string
	if w.opts.RemoveComments {
		options = append(options, &quot;comments removed&quot;)
	}
	if w.opts.RemoveEmptyLines {
		options = append(options, &quot;empty lines removed&quot;)
	}
	if w.opts.CompressCode {
		options = append(options, &quot;code compressed&quot;)
	}

	if len(options) &gt; 0 {
		if _, err := w.writer.WriteString(strings.Join(options, &quot;, &quot;)); err != nil {
			return err
		}
	} else {
		if _, err := w.writer.WriteString(&quot;no processing applied&quot;); err != nil {
			return err
		}
	}
	if _, err := w.writer.WriteString(&quot; --&gt;\n\n&quot;); err != nil {
		return err
	}

	// File summary section
	if w.opts.IncludeSummary {
		summary := `&lt;file_summary&gt;
This section contains a summary of this file.

&lt;purpose&gt;
This file contains a packed representation of the entire repository&#39;s contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
&lt;/purpose&gt;

&lt;file_format&gt;
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure (if enabled)
4. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
&lt;/file_format&gt;

&lt;usage_guidelines&gt;
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
&lt;/usage_guidelines&gt;

&lt;notes&gt;
- Some files may have been excluded based on .gitignore rules and CodeEcho&#39;s configuration
- Binary files are not included in this packed representation
- Files matching default ignore patterns are excluded
`
		if _, err := w.writer.WriteString(summary); err != nil {
			return err
		}

		if w.opts.RemoveComments || w.opts.RemoveEmptyLines || w.opts.CompressCode {
			if _, err := w.writer.WriteString(&quot;- File processing has been applied - content may differ from original files\n&quot;); err != nil {
				return err
			}
		}

		if _, err := w.writer.WriteString(fmt.Sprintf(&quot;- Generated by CodeEcho CLI on %s\n&quot;, scanTime)); err != nil {
			return err
		}
		if _, err := w.writer.WriteString(&quot;&lt;/notes&gt;\n\n&lt;/file_summary&gt;\n\n&quot;); err != nil {
			return err
		}
	}

	// Repository info (will update stats in footer)
	if _, err := w.writer.WriteString(fmt.Sprintf(&quot;&lt;repository_info&gt;\n&lt;repo_path&gt;%s&lt;/repo_path&gt;\n&lt;scan_time&gt;%s&lt;/scan_time&gt;\n&lt;/repository_info&gt;\n\n&quot;, escapeXML(repoPath), scanTime)); err != nil {
		return err
	}

	// Start files section
	if _, err := w.writer.WriteString(&quot;&lt;files&gt;\nThis section contains the contents of the repository&#39;s files.\n\n&quot;); err != nil {
		return err
	}

	return nil
}

func (w *StreamingXMLWriter) WriteTree(paths []string) error {
	if !w.opts.IncludeDirectoryTree || len(paths) == 0 {
		return nil
	}

	// Convert paths to FileInfo structs (minimal data)
	fileInfos := make([]scanner.FileInfo, len(paths))
	for i, path := range paths {
		fileInfos[i] = scanner.FileInfo{RelativePath: path}
	}

	tree := GenerateDirectoryTree(fileInfos)

	if _, err := w.writer.WriteString(&quot;&lt;directory_structure&gt;\n&quot;); err != nil {
		return err
	}
	if _, err := w.writer.WriteString(tree); err != nil {
		return err
	}
	if _, err := w.writer.WriteString(&quot;&lt;/directory_structure&gt;\n\n&quot;); err != nil {
		return err
	}

	return nil
}

// WriteFile writes a single file entry
// This is called once per file - the key to streaming!
func (w *StreamingXMLWriter) WriteFile(file *scanner.FileInfo) error {
	// Update statistics as we go
	w.stats.TotalFiles++
	w.stats.TotalSize += file.Size

	if file.IsText {
		w.stats.TextFiles++
	} else {
		w.stats.BinaryFiles++
	}

	if file.Language != &quot;&quot; {
		w.stats.LanguageCounts[file.Language]++
	}

	// Write file opening tag with attributes
	if _, err := w.writer.WriteString(fmt.Sprintf(`&lt;file path=&quot;%s&quot;`, escapeXML(file.RelativePath))); err != nil {
		return err
	}

	if file.Language != &quot;&quot; {
		if _, err := w.writer.WriteString(fmt.Sprintf(` language=&quot;%s&quot;`, file.Language)); err != nil {
			return err
		}
	}

	if file.LineCount &gt; 0 {
		if _, err := w.writer.WriteString(fmt.Sprintf(` lines=&quot;%d&quot;`, file.LineCount)); err != nil {
			return err
		}
	}

	if _, err := w.writer.WriteString(fmt.Sprintf(` size=&quot;%s&quot;`, file.SizeFormatted)); err != nil {
		return err
	}

	if file.Extension != &quot;&quot; {
		if _, err := w.writer.WriteString(fmt.Sprintf(` extension=&quot;%s&quot;`, file.Extension)); err != nil {
			return err
		}
	}

	if _, err := w.writer.WriteString(fmt.Sprintf(` modified=&quot;%s&quot;`, file.ModTimeFormatted)); err != nil {
		return err
	}

	if _, err := w.writer.WriteString(fmt.Sprintf(` is_text=&quot;%t&quot;`, file.IsText)); err != nil {
		return err
	}

	if _, err := w.writer.WriteString(&quot;&gt;\n&quot;); err != nil {
		return err
	}

	// Write content
	if w.opts.IncludeContent &amp;&amp; file.Content != &quot;&quot; &amp;&amp; file.IsText {
		if w.opts.ShowLineNumbers {
			numbered := addLineNumbers(file.Content)
			if _, err := w.writer.WriteString(numbered); err != nil {
				return err
			}
		} else {
			escaped := escapeXML(file.Content)
			if _, err := w.writer.WriteString(escaped); err != nil {
				return err
			}
		}
	} else if !file.IsText {
		if _, err := w.writer.WriteString(&quot;&lt;!-- Binary file - content not included --&gt;&quot;); err != nil {
			return err
		}
	} else {
		if _, err := w.writer.WriteString(&quot;&lt;!-- Content not included --&gt;&quot;); err != nil {
			return err
		}
	}

	// Close file tag
	if _, err := w.writer.WriteString(&quot;\n&lt;/file&gt;\n\n&quot;); err != nil {
		return err
	}

	return nil
}

// WriteFooter writes closing tags and final statistics
func (w *StreamingXMLWriter) WriteFooter(stats *scanner.StreamingStats) error {
	// Close files section
	if _, err := w.writer.WriteString(&quot;&lt;/files&gt;\n\n&quot;); err != nil {
		return err
	}

	// Write final statistics section
	statsXML := fmt.Sprintf(`&lt;scan_statistics&gt;
&lt;total_files&gt;%d&lt;/total_files&gt;
&lt;total_size&gt;%s&lt;/total_size&gt;
&lt;text_files&gt;%d&lt;/text_files&gt;
&lt;binary_files&gt;%d&lt;/binary_files&gt;
&lt;/scan_statistics&gt;
`, stats.TotalFiles, utils.FormatBytes(stats.TotalSize), stats.TextFiles, stats.BinaryFiles)

	if _, err := w.writer.WriteString(statsXML); err != nil {
		return err
	}

	return nil
}

// Close flushes the buffer and closes the writer
func (w *StreamingXMLWriter) Close() error {
	return w.writer.Flush() // Important: flush buffered data to disk
}

// Helper functions for XML processing
func escapeXML(s string) string {
	s = strings.ReplaceAll(s, &quot;&amp;&quot;, &quot;&amp;amp;&quot;)
	s = strings.ReplaceAll(s, &quot;&lt;&quot;, &quot;&amp;lt;&quot;)
	s = strings.ReplaceAll(s, &quot;&gt;&quot;, &quot;&amp;gt;&quot;)
	s = strings.ReplaceAll(s, `&quot;`, &quot;&amp;quot;&quot;)
	s = strings.ReplaceAll(s, `&#39;`, &quot;&amp;#39;&quot;)
	return s
}

func addLineNumbers(content string) string {
	lines := strings.Split(content, &quot;\n&quot;)
	var numberedLines []string

	for i, line := range lines {
		numberedLines = append(numberedLines, fmt.Sprintf(&quot;%4d: %s&quot;, i+1, line))
	}

	return strings.Join(numberedLines, &quot;\n&quot;)
}

</file>

<file path="output/tree.go" language="go" lines="55" size="1.2 KB" extension=".go" modified="2025-10-14 16:13:48" is_text="true">
package output

import (
	&quot;fmt&quot;
	&quot;path/filepath&quot;
	&quot;strings&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/scanner&quot;
)

func GenerateDirectoryTree(files []scanner.FileInfo) string {
	if len(files) == 0 {
		return &quot;&quot;
	}

	// Determine project root name
	projectRoot := &quot;project&quot;
	if len(files) &gt; 0 &amp;&amp; files[0].Path != &quot;&quot; {
		dir := filepath.Dir(files[0].Path)
		if dir != &quot;.&quot; &amp;&amp; dir != &quot;/&quot; {
			projectRoot = filepath.Base(dir)
		}
	}

	// Build directory structure
	var result strings.Builder
	result.WriteString(projectRoot + &quot;/\n&quot;)

	// Track processed paths to avoid duplicates
	processed := make(map[string]bool)

	for _, file := range files {
		parts := strings.Split(file.RelativePath, string(filepath.Separator))

		// Build each level of the path
		for i := range parts {
			pathSoFar := strings.Join(parts[:i+1], &quot;/&quot;)

			if !processed[pathSoFar] {
				processed[pathSoFar] = true
				indent := strings.Repeat(&quot;  &quot;, i+1)

				if i == len(parts)-1 {
					// It&#39;s a file
					result.WriteString(fmt.Sprintf(&quot;%s%s\n&quot;, indent, parts[i]))
				} else {
					// It&#39;s a directory
					result.WriteString(fmt.Sprintf(&quot;%s%s/\n&quot;, indent, parts[i]))
				}
			}
		}
	}

	return result.String()
}

</file>

<file path="scanner/analysis.go" language="go" lines="185" size="4.6 KB" extension=".go" modified="2025-10-14 16:11:35" is_text="true">
package scanner

import (
	&quot;io/fs&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;
	&quot;sort&quot;
	&quot;time&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/utils&quot;
)

type AnalysisScanner struct {
	rootPath string
	opts     ScanOptions

	// NEW: Progress and error tracking
	progressCallback ProgressCallback
	errors           []ScanError
	startTime        time.Time
}

func NewAnalysisScanner(rootPath string, opts ScanOptions) *AnalysisScanner {
	return &amp;AnalysisScanner{
		rootPath: rootPath,
		opts:     opts,
		errors:   []ScanError{},
	}
}

// NEW: Set progress callback
func (a *AnalysisScanner) SetProgressCallback(callback ProgressCallback) {
	a.progressCallback = callback
}

// NEW: Get collected errors
func (a *AnalysisScanner) GetErrors() []ScanError {
	return a.errors
}

// NEW: Report progress
func (a *AnalysisScanner) reportProgress(phase string, currentFile string, processed, total int) {
	if a.progressCallback == nil {
		return
	}

	progress := ScanProgress{
		Phase:          phase,
		CurrentFile:    currentFile,
		ProcessedFiles: processed,
		TotalFiles:     total,
	}

	if total &gt; 0 {
		progress.Percentage = float64(processed) / float64(total) * 100
	}

	a.progressCallback(progress)
}

// NEW: Record error
func (a *AnalysisScanner) recordError(path string, phase string, err error) {
	a.errors = append(a.errors, ScanError{
		Path:    path,
		Phase:   phase,
		Error:   err,
		Skipped: true,
	})
}

// Scan performs a full repository scan and returns complete results
// Unlike StreamingScanner, this keeps all data in memory
func (a *AnalysisScanner) Scan() (*ScanResult, error) {
	a.startTime = time.Now()

	result := &amp;ScanResult{
		RepoPath:       a.rootPath,
		ScanTime:       time.Now().Format(time.RFC3339),
		Files:          []FileInfo{},
		ProcessedBy:    &quot;CodeEcho CLI&quot;,
		LanguageCounts: make(map[string]int),
	}

	// First pass: Count total files
	a.reportProgress(&quot;counting&quot;, &quot;calculating total files...&quot;, 0, 0)
	totalFiles := 0
	filepath.WalkDir(a.rootPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return nil
		}
		if !d.IsDir() &amp;&amp; shouldIncludeFile(path, a.opts.IncludeExts) {
			if d.IsDir() &amp;&amp; shouldExcludeDir(d.Name(), a.opts.ExcludeDirs) {
				return filepath.SkipDir
			}
			totalFiles++
		}
		return nil
	})

	// Second pass: Process files
	processedFiles := 0
	err := filepath.WalkDir(a.rootPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			a.recordError(path, &quot;scan&quot;, err)
			return nil // Continue
		}

		// Skip excluded directories
		if d.IsDir() &amp;&amp; shouldExcludeDir(d.Name(), a.opts.ExcludeDirs) {
			return filepath.SkipDir
		}

		// Process files only
		if !d.IsDir() &amp;&amp; shouldIncludeFile(path, a.opts.IncludeExts) {
			relativePath := utils.GetRelativePath(a.rootPath, path)
			a.reportProgress(&quot;scanning&quot;, relativePath, processedFiles, totalFiles)

			info, err := d.Info()
			if err != nil {
				a.recordError(path, &quot;stat&quot;, err)
				return nil // Continue
			}

			language := detectLanguage(path)
			extension := filepath.Ext(path)

			fileInfo := FileInfo{
				Path:             path,
				RelativePath:     relativePath,
				Size:             info.Size(),
				SizeFormatted:    utils.FormatBytes(info.Size()),
				ModTime:          info.ModTime().Format(time.RFC3339),
				ModTimeFormatted: info.ModTime().Format(&quot;2006-01-02 15:04:05&quot;),
				Language:         language,
				Extension:        extension,
				IsText:           isTextFile(path, extension),
			}

			// Include content if requested and it&#39;s a text file
			if a.opts.IncludeContent &amp;&amp; fileInfo.IsText {
				content, err := os.ReadFile(path)
				if err != nil {
					a.recordError(path, &quot;read&quot;, err)
				} else {
					// ENHANCED: Content-based detection
					if fileInfo.Language == &quot;&quot; {
						fileInfo.Language = detectLanguageFromContent(path, content)
					}
					if !fileInfo.IsText &amp;&amp; isTextContent(content) {
						fileInfo.IsText = true
					}

					processedContent := processFileContent(string(content), fileInfo.Language, a.opts)
					fileInfo.Content = processedContent
					fileInfo.LineCount = utils.CountLines(processedContent)
				}
			}

			result.Files = append(result.Files, fileInfo)
			result.TotalFiles++
			result.TotalSize += info.Size()

			if fileInfo.IsText {
				result.TextFiles++
			} else {
				result.BinaryFiles++
			}

			if fileInfo.Language != &quot;&quot; {
				result.LanguageCounts[fileInfo.Language]++
			}
			processedFiles++
		}

		return nil
	})

	// Sort files by path for consistent output
	a.reportProgress(&quot;sorting&quot;, &quot;organizing results...&quot;, totalFiles, totalFiles)
	sort.Slice(result.Files, func(i, j int) bool {
		return result.Files[i].RelativePath &lt; result.Files[j].RelativePath
	})

	return result, err
}

</file>

<file path="scanner/filters.go" language="go" lines="25" size="462 B" extension=".go" modified="2025-09-30 08:06:42" is_text="true">
package scanner

import &quot;strings&quot;

func shouldExcludeDir(dirName string, excludeDirs []string) bool {
	for _, excluded := range excludeDirs {
		if dirName == excluded {
			return true
		}
	}
	return false
}

func shouldIncludeFile(path string, includeExts []string) bool {
	if len(includeExts) == 0 {
		return true
	}

	for _, ext := range includeExts {
		if strings.HasSuffix(strings.ToLower(path), strings.ToLower(ext)) {
			return true
		}
	}
	return false
}

</file>

<file path="scanner/language.go" language="go" lines="247" size="6.7 KB" extension=".go" modified="2025-10-08 13:07:27" is_text="true">
package scanner

import (
	&quot;bytes&quot;
	&quot;path/filepath&quot;
	&quot;strings&quot;
	&quot;unicode/utf8&quot;
)

func detectLanguage(path string) string {
	ext := strings.ToLower(filepath.Ext(path))
	langMap := map[string]string{
		&quot;.go&quot;:   &quot;go&quot;,
		&quot;.js&quot;:   &quot;javascript&quot;,
		&quot;.ts&quot;:   &quot;typescript&quot;,
		&quot;.jsx&quot;:  &quot;jsx&quot;,
		&quot;.tsx&quot;:  &quot;tsx&quot;,
		&quot;.py&quot;:   &quot;python&quot;,
		&quot;.java&quot;: &quot;java&quot;,
		&quot;.cpp&quot;:  &quot;cpp&quot;,
		&quot;.c&quot;:    &quot;c&quot;,
		&quot;.h&quot;:    &quot;c&quot;,
		&quot;.rs&quot;:   &quot;rust&quot;,
		&quot;.rb&quot;:   &quot;ruby&quot;,
		&quot;.php&quot;:  &quot;php&quot;,
		&quot;.css&quot;:  &quot;css&quot;,
		&quot;.html&quot;: &quot;html&quot;,
		&quot;.json&quot;: &quot;json&quot;,
		&quot;.md&quot;:   &quot;markdown&quot;,
		&quot;.yml&quot;:  &quot;yaml&quot;,
		&quot;.yaml&quot;: &quot;yaml&quot;,
		&quot;.toml&quot;: &quot;toml&quot;,
		&quot;.xml&quot;:  &quot;xml&quot;,
	}

	if lang, exists := langMap[ext]; exists {
		return lang
	}
	return &quot;&quot;
}

// ENHANCED: Now checks content for unknown types
// Files without extensions or misnamed files need content inspection
func isTextFile(path, extension string) bool {
	// Step 1: Try fast extension-based detection first
	ext := strings.ToLower(extension)
	if isTextExtension(ext) {
		return true
	}

	// Step 2: Try filename-based detection (no extension files)
	fileName := strings.ToLower(filepath.Base(path))
	if isTextFilename(fileName) {
		return true
	}

	// Step 3: If still unknown, we&#39;ll need content sampling
	// (This happens in the scanner when we read the file)
	return false
}

// Separated extension checking for clarity
// Makes the logic clearer and easier to maintain
func isTextExtension(ext string) bool {
	textExtensions := map[string]bool{
		&quot;.txt&quot;: true, &quot;.md&quot;: true, &quot;.rst&quot;: true, &quot;.asciidoc&quot;: true,
		&quot;.go&quot;: true, &quot;.py&quot;: true, &quot;.js&quot;: true, &quot;.ts&quot;: true, &quot;.jsx&quot;: true, &quot;.tsx&quot;: true,
		&quot;.java&quot;: true, &quot;.c&quot;: true, &quot;.cpp&quot;: true, &quot;.cc&quot;: true, &quot;.cxx&quot;: true, &quot;.h&quot;: true, &quot;.hpp&quot;: true,
		&quot;.cs&quot;: true, &quot;.php&quot;: true, &quot;.rb&quot;: true, &quot;.rs&quot;: true, &quot;.swift&quot;: true, &quot;.kt&quot;: true,
		&quot;.html&quot;: true, &quot;.htm&quot;: true, &quot;.xml&quot;: true, &quot;.xhtml&quot;: true,
		&quot;.css&quot;: true, &quot;.scss&quot;: true, &quot;.sass&quot;: true, &quot;.less&quot;: true,
		&quot;.json&quot;: true, &quot;.yaml&quot;: true, &quot;.yml&quot;: true, &quot;.toml&quot;: true, &quot;.ini&quot;: true, &quot;.cfg&quot;: true, &quot;.conf&quot;: true,
		&quot;.sh&quot;: true, &quot;.bash&quot;: true, &quot;.zsh&quot;: true, &quot;.fish&quot;: true, &quot;.ps1&quot;: true, &quot;.bat&quot;: true, &quot;.cmd&quot;: true,
		&quot;.sql&quot;: true, &quot;.graphql&quot;: true, &quot;.gql&quot;: true,
		&quot;.dockerfile&quot;: true, &quot;.gitignore&quot;: true, &quot;.gitattributes&quot;: true,
		&quot;.makefile&quot;: true, &quot;.cmake&quot;: true,
		&quot;.r&quot;: true, &quot;.rmd&quot;: true, &quot;.m&quot;: true, &quot;.scala&quot;: true, &quot;.clj&quot;: true, &quot;.hs&quot;: true,
		&quot;.vim&quot;: true, &quot;.lua&quot;: true, &quot;.pl&quot;: true, &quot;.tcl&quot;: true,
		&quot;.tex&quot;: true, &quot;.bib&quot;: true, &quot;.cls&quot;: true, &quot;.sty&quot;: true,
		&quot;.csv&quot;: true, &quot;.tsv&quot;: true, &quot;.log&quot;: true,
	}
	return textExtensions[ext]
}

// Separated filename checking for clarity
// Keeps the logic organized and testable
func isTextFilename(fileName string) bool {
	textFiles := map[string]bool{
		&quot;readme&quot;: true, &quot;license&quot;: true, &quot;changelog&quot;: true, &quot;contributing&quot;: true,
		&quot;authors&quot;: true, &quot;contributors&quot;: true, &quot;copying&quot;: true, &quot;install&quot;: true,
		&quot;news&quot;: true, &quot;thanks&quot;: true, &quot;todo&quot;: true, &quot;version&quot;: true,
		&quot;makefile&quot;: true, &quot;dockerfile&quot;: true, &quot;jenkinsfile&quot;: true,
		&quot;gemfile&quot;: true, &quot;rakefile&quot;: true, &quot;guardfile&quot;: true, &quot;procfile&quot;: true,
		&quot;.gitignore&quot;: true, &quot;.gitattributes&quot;: true, &quot;.dockerignore&quot;: true,
		&quot;.eslintrc&quot;: true, &quot;.prettierrc&quot;: true, &quot;.babelrc&quot;: true,
	}
	return textFiles[fileName]
}

// Content-based text detection
// Last resort for files we can&#39;t identify by name/extension
// Algorithm:
//   1. Check for null bytes (binary indicator)
//   2. Validate UTF-8 encoding
//   3. Check printable character ratio

func isTextContent(data []byte) bool {

	if len(data) == 0 {
		return true // Empty file is technically text
	}

	// Sample size: Check first 8KB (enough to identify most files)
	// 8KB? Balance between speed and accuracy
	sampleSize := 8192
	if len(data) &lt; sampleSize {
		sampleSize = len(data)
	}
	sample := data[:sampleSize]

	// Rule 1: Binary files often contain null bytes
	// Why: Text files rarely have \x00 characters
	if bytes.Contains(sample, []byte{0}) {
		return false
	}

	// Rule 2: Text files must be valid UTF-8
	// Why: If it&#39;s not valid UTF-8, it&#39;s likely binary
	if !utf8.Valid(sample) {
		// Allow some invalid UTF-8 for legacy encodings
		// If more than 10% is invalid, it&#39;s likely binary
		invalidCount := 0
		for len(sample) &gt; 0 {
			r, size := utf8.DecodeRune(sample)
			if r == utf8.RuneError &amp;&amp; size == 1 {
				invalidCount++
			}
			sample = sample[size:]
		}
		invalidRatio := float64(invalidCount) / float64(sampleSize)
		if invalidRatio &gt; 0.1 {
			return false
		}
	}

	// Rule 3: Check printable character ratio
	// Text files should be mostly printable
	printableCount := 0
	for _, b := range sample {
		// Printable ASCII: 0x20-0x7E, plus common whitespace
		if (b &gt;= 0x20 &amp;&amp; b &lt;= 0x7E) || b == &#39;\r&#39; || b == &#39;\t&#39; {
			printableCount++
		}
	}
	printableRatio := float64(printableCount) / float64(len(sample))
	// If 80%+ is printable, it&#39;s probably text
	// 80%? Allows for some special characters in UTF-8
	return printableRatio &gt;= 0.8
}

// Detect language from file content (shebang, patterns)
// Files without extensions need content analysis
func detectLanguageFromContent(path string, content []byte) string {
	// try shebang for scripts
	if lang := detectFromShebang(content); lang != &quot;&quot; {
		return lang
	}

	// try content patterns
	if lang := detectFromPatterns(content); lang != &quot;&quot; {
		return lang
	}

	return &quot;&quot;
}

// Shebang detection
// Script files often lack extensions but have shebangs
func detectFromShebang(content []byte) string {
	if len(content) &lt; 3 || !bytes.HasPrefix(content, []byte(&quot;#!&quot;)) {
		return &quot;&quot;
	}

	// Read first line
	firstLine := content
	if idx := bytes.IndexByte(content, &#39;\n&#39;); idx &gt; 0 {
		firstLine = content[:idx]
	}

	shebang := string(firstLine)

	// Common shebang patterns
	patterns := map[string]string{
		&quot;python&quot;:    &quot;python&quot;,
		&quot;node&quot;:      &quot;javascript&quot;,
		&quot;ruby&quot;:      &quot;ruby&quot;,
		&quot;perl&quot;:      &quot;perl&quot;,
		&quot;bash&quot;:      &quot;bash&quot;,
		&quot;sh&quot;:        &quot;shell&quot;,
		&quot;/bin/sh&quot;:   &quot;shell&quot;,
		&quot;/bin/bash&quot;: &quot;bash&quot;,
		&quot;php&quot;:       &quot;php&quot;,
	}

	for pattern, lang := range patterns {
		if strings.Contains(strings.ToLower(shebang), pattern) {
			return lang
		}
	}

	return &quot;&quot;
}

// Pattern-based detection
// Some file types have distinctive patterns
func detectFromPatterns(content []byte) string {
	// Sample first 1KB for pattern matching
	// Why 1KB? Most file signatures appear early
	sampleSize := 1024
	if len(content) &lt; sampleSize {
		sampleSize = len(content)
	}
	sample := strings.ToLower(string(content[:sampleSize]))

	// Check for distinctive patterns
	patterns := []struct {
		pattern string
		lang    string
	}{
		{&quot;&lt;?php&quot;, &quot;php&quot;},
		{&quot;&lt;?xml&quot;, &quot;xml&quot;},
		{&quot;&lt;!doctype html&quot;, &quot;html&quot;},
		{&quot;&lt;html&quot;, &quot;html&quot;},
		{&quot;import react&quot;, &quot;jsx&quot;},
		{&quot;from react&quot;, &quot;jsx&quot;},
		{&quot;package main&quot;, &quot;go&quot;},
		{&quot;#!/usr/bin/env python&quot;, &quot;python&quot;},
	}

	for _, p := range patterns {
		if strings.Contains(sample, p.pattern) {
			return p.lang
		}
	}

	return &quot;&quot;
}

</file>

<file path="scanner/process.go" language="go" lines="94" size="2.4 KB" extension=".go" modified="2025-09-30 08:05:00" is_text="true">
package scanner

import (
	&quot;encoding/json&quot;
	&quot;regexp&quot;
	&quot;strings&quot;
)

func processFileContent(content, language string, opts ScanOptions) string {
	processed := content

	if opts.RemoveComments {
		processed = stripComments(processed, language)
	}
	if opts.RemoveEmptyLines {
		processed = stripEmptyLines(processed)
	}
	if opts.CompressCode {
		processed = compressWhitespace(processed, language)
	}

	return processed
}

// stripComments removes comments based on file language
func stripComments(content, language string) string {
	switch language {
	case &quot;go&quot;, &quot;javascript&quot;, &quot;typescript&quot;, &quot;java&quot;, &quot;cpp&quot;, &quot;c&quot;, &quot;rust&quot;, &quot;php&quot;:
		// Remove single-line comments //
		re1 := regexp.MustCompile(`//.*$`)
		content = re1.ReplaceAllString(content, &quot;&quot;)

		// Remove multi-line comments /* */
		re2 := regexp.MustCompile(`/\*[\s\S]*?\*/`)
		content = re2.ReplaceAllString(content, &quot;&quot;)

	case &quot;python&quot;, &quot;ruby&quot;:
		// Remove # comments
		re := regexp.MustCompile(`#.*$`)
		content = re.ReplaceAllString(content, &quot;&quot;)

	case &quot;html&quot;, &quot;xml&quot;:
		// Remove HTML/XML comments &lt;!-- --&gt;
		re := regexp.MustCompile(`&lt;!--[\s\S]*?--&gt;`)
		content = re.ReplaceAllString(content, &quot;&quot;)

	case &quot;css&quot;:
		// Remove CSS comments /* */
		re := regexp.MustCompile(`/\*[\s\S]*?\*/`)
		content = re.ReplaceAllString(content, &quot;&quot;)
	}

	return content
}

// stripEmptyLines removes empty lines from content
func stripEmptyLines(content string) string {
	lines := strings.Split(content, &quot;\n&quot;)
	var nonEmptyLines []string

	for _, line := range lines {
		if strings.TrimSpace(line) != &quot;&quot; {
			nonEmptyLines = append(nonEmptyLines, line)
		}
	}

	return strings.Join(nonEmptyLines, &quot;\n&quot;)
}

// compressWhitespace removes unnecessary whitespace
func compressWhitespace(content, language string) string {
	switch language {
	case &quot;json&quot;:
		// For JSON, we can actually minify it properly
		var jsonObj interface{}
		if err := json.Unmarshal([]byte(content), &amp;jsonObj); err == nil {
			if minified, err := json.Marshal(jsonObj); err == nil {
				return string(minified)
			}
		}
	case &quot;javascript&quot;, &quot;css&quot;:
		// Basic whitespace compression for JS/CSS
		// Remove extra spaces and tabs (but preserve single spaces)
		re := regexp.MustCompile(`[ \t]+`)
		content = re.ReplaceAllString(content, &quot; &quot;)
	}

	// Generic whitespace compression
	// Remove trailing whitespace from each line
	re := regexp.MustCompile(`[ \t]+$`)
	content = re.ReplaceAllString(content, &quot;&quot;)

	return content
}

</file>

<file path="scanner/streaming.go" language="go" lines="259" size="6.6 KB" extension=".go" modified="2025-10-14 16:14:03" is_text="true">
package scanner

import (
	&quot;fmt&quot;
	&quot;io/fs&quot;
	&quot;os&quot;
	&quot;path/filepath&quot;
	&quot;time&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/utils&quot;
)

type StreamingScanner struct {
	rootPath    string
	opts        ScanOptions
	fileHandler func(*FileInfo) error
	treeWriter  func([]string) error

	// NEW: Progress and error tracking
	progressCallback ProgressCallback
	errors           []ScanError

	stats     *StreamingStats
	filePaths []string

	// NEW: Timing
	startTime time.Time
}

// StreamingStats tracks lightweight counters (not full file data)
type StreamingStats struct {
	TotalFiles     int
	TotalSize      int64
	TextFiles      int
	BinaryFiles    int
	LanguageCounts map[string]int
}

// NewStreamingScanner creates a scanner that calls fileHandler for each file
func NewStreamingScanner(rootPath string, opts ScanOptions, fileHandler func(*FileInfo) error) *StreamingScanner {
	return &amp;StreamingScanner{
		rootPath:    rootPath,
		opts:        opts,
		fileHandler: fileHandler,
		stats: &amp;StreamingStats{
			LanguageCounts: make(map[string]int),
		},
		filePaths: []string{},
		errors:    []ScanError{}, // Initialize error slice
	}
}

// NEW: Set progress callback
// Why: Allow external progress monitoring
func (s *StreamingScanner) SetProgressCallback(callback ProgressCallback) {
	s.progressCallback = callback
}

func (s *StreamingScanner) SetTreeWriter(treeWriter func([]string) error) {
	s.treeWriter = treeWriter
}

func (s *StreamingScanner) GetFilePaths() []string {
	return s.filePaths
}

// NEW: Get collected errors
// Why: Return all errors at the end
func (s *StreamingScanner) GetErrors() []ScanError {
	return s.errors
}

// NEW: Report progress
// Why: Centralized progress reporting
func (s *StreamingScanner) reportProgress(phase string, currentFile string) {
	if s.progressCallback == nil {
		return
	}

	progress := ScanProgress{
		Phase:          phase,
		CurrentFile:    currentFile,
		ProcessedFiles: s.stats.TotalFiles,
		TotalFiles:     len(s.filePaths),
		BytesProcessed: s.stats.TotalSize,
	}

	// calculate percentage
	if len(s.filePaths) &gt; 0 {
		progress.Percentage = float64(s.stats.TextFiles) / float64(len(s.filePaths)) * 100
	}

	s.progressCallback(progress)
}

// NEW: Record error
// Why: Collect errors instead of just logging
func (s *StreamingScanner) recordError(path string, phase string, err error, skipped bool) {
	s.errors = append(s.errors, ScanError{
		Path:    path,
		Phase:   phase,
		Error:   err,
		Skipped: skipped,
	})

	// Still log for debugging
	if skipped {
		fmt.Fprintf(os.Stderr, &quot;Warning: skipping %s: %v\n&quot;, path, err)
	} else {
		fmt.Fprintf(os.Stderr, &quot;Error processing %s: %v\n&quot;, path, err)
	}
}

// Update: Enhanced with error tracking
func (s *StreamingScanner) collectPaths() error {
	s.reportProgress(&quot;collecting&quot;, &quot;scanning directories...&quot;)

	return filepath.WalkDir(s.rootPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			fmt.Fprintf(os.Stderr, &quot;Warning: skipping %s: %v\n&quot;, path, err)
			return nil // Continue scanning
		}

		// Skip excluded directories
		if d.IsDir() &amp;&amp; shouldExcludeDir(d.Name(), s.opts.ExcludeDirs) {
			return filepath.SkipDir
		}

		// Collect file paths only
		if !d.IsDir() &amp;&amp; shouldIncludeFile(path, s.opts.IncludeExts) {
			relativePath := utils.GetRelativePath(s.rootPath, path)
			s.filePaths = append(s.filePaths, relativePath)
		}

		return nil
	})
}

// Scan walks the directory and calls fileHandler for each file
// This is where streaming happens - we don&#39;t accumulate anything!
// Scan - Enhanced with progress and error tracking
func (s *StreamingScanner) Scan() (*StreamingStats, error) {
	s.startTime = time.Now()

	// Phase 1: Collect paths if tree is needed
	if s.opts.IncludeDirectoryTree {
		if err := s.collectPaths(); err != nil {
			return nil, fmt.Errorf(&quot;failed to collect paths: %w&quot;, err)
		}

		// Write tree immediately after collecting paths
		if s.treeWriter != nil {
			s.reportProgress(&quot;tree&quot;, &quot;writing directory structure...&quot;)
			if err := s.treeWriter(s.filePaths); err != nil {
				return nil, fmt.Errorf(&quot;failed to write tree: %w&quot;, err)
			}
		}
	}

	// Phase 2: Process files and stream content
	s.reportProgress(&quot;scanning&quot;, &quot;processing files...&quot;)

	err := filepath.WalkDir(s.rootPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			s.recordError(path, &quot;scan&quot;, err, true)
			return nil // Continue
		}

		// Skip excluded directories
		if d.IsDir() &amp;&amp; shouldExcludeDir(d.Name(), s.opts.ExcludeDirs) {
			return filepath.SkipDir
		}

		// Process files only
		if !d.IsDir() &amp;&amp; shouldIncludeFile(path, s.opts.IncludeExts) {
			if err := s.processFile(path, d); err != nil {
				// Error recorded in processFile
				return nil // Continue scanning
			}
		}

		return nil
	})

	return s.stats, err
}

// Update: Separated file processing
// Why: Makes error handling cleaner and more testable
func (s *StreamingScanner) processFile(path string, d fs.DirEntry) error {
	info, err := d.Info()
	if err != nil {
		s.recordError(path, &quot;stat&quot;, err, true)
		return err
	}

	relativePath := utils.GetRelativePath(s.rootPath, path)
	s.reportProgress(&quot;scanning&quot;, relativePath)

	language := detectLanguage(path)
	extension := filepath.Ext(path)

	fileInfo := FileInfo{
		Path:             path,
		RelativePath:     relativePath,
		Size:             info.Size(),
		SizeFormatted:    utils.FormatBytes(info.Size()),
		ModTime:          info.ModTime().Format(time.RFC3339),
		ModTimeFormatted: info.ModTime().Format(&quot;2006-01-02 15:04:05&quot;),
		Language:         language,
		Extension:        extension,
		IsText:           isTextFile(path, extension),
	}

	// Read and process content if requested
	if s.opts.IncludeContent &amp;&amp; fileInfo.IsText {
		content, err := os.ReadFile(path)
		if err != nil {
			s.recordError(path, &quot;read&quot;, err, true)
			// Continue with empty content
		} else {
			// ENHANCED: Try content-based detection if language unknown
			if fileInfo.Language == &quot;&quot; {
				fileInfo.Language = detectLanguageFromContent(path, content)
			}

			// ENHANCED: Re-check if text using content
			if !fileInfo.IsText &amp;&amp; isTextContent(content) {
				fileInfo.IsText = true
			}

			processedContent := processFileContent(string(content), fileInfo.Language, s.opts)
			fileInfo.Content = processedContent
			fileInfo.LineCount = utils.CountLines(processedContent)
		}
	}

	// Update statistics
	s.stats.TotalFiles++
	s.stats.TotalSize += info.Size()

	if fileInfo.IsText {
		s.stats.TextFiles++
	} else {
		s.stats.BinaryFiles++
	}

	if fileInfo.Language != &quot;&quot; {
		s.stats.LanguageCounts[fileInfo.Language]++
	}

	// Call handler immediately, then discard from memory
	if err := s.fileHandler(&amp;fileInfo); err != nil {
		s.recordError(path, &quot;write&quot;, err, false)
		return fmt.Errorf(&quot;error writing file %s: %w&quot;, path, err)
	}

	return nil
}

</file>

<file path="scanner/types.go" language="go" lines="73" size="2.2 KB" extension=".go" modified="2025-10-08 12:26:14" is_text="true">
package scanner

type FileInfo struct {
	Path             string `json:&quot;path&quot;`
	RelativePath     string `json:&quot;relative_path&quot;`
	Size             int64  `json:&quot;size&quot;`
	SizeFormatted    string `json:&quot;size_formatted&quot;`
	ModTime          string `json:&quot;mod_time&quot;`
	ModTimeFormatted string `json:&quot;mod_time_formatted&quot;`
	Content          string `json:&quot;content,omitempty&quot;`
	Language         string `json:&quot;language,omitempty&quot;`
	LineCount        int    `json:&quot;line_count,omitempty&quot;`
	Extension        string `json:&quot;extension,omitempty&quot;`
	IsText           bool   `json:&quot;is_text&quot;`
}

type ScanResult struct {
	RepoPath       string         `json:&quot;repo_path&quot;`
	ScanTime       string         `json:&quot;scan_time&quot;`
	TotalFiles     int            `json:&quot;total_files&quot;`
	TotalSize      int64          `json:&quot;total_size&quot;`
	Files          []FileInfo     `json:&quot;files,omitempty&quot;`
	ProcessedBy    string         `json:&quot;processed_by&quot;`
	TextFiles      int            `json:&quot;text_files&quot;`
	BinaryFiles    int            `json:&quot;binary_files&quot;`
	LanguageCounts map[string]int `json:&quot;language_counts&quot;`
}

type ScanOptions struct {
	IncludeSummary       bool
	IncludeDirectoryTree bool
	ShowLineNumbers      bool
	OutputParsableFormat bool

	CompressCode     bool
	RemoveComments   bool
	RemoveEmptyLines bool

	ExcludeDirs    []string
	IncludeExts    []string
	IncludeContent bool
}

// Progress tracking
type ScanProgress struct {
	Phase          string  // &quot;collecting&quot;, &quot;scanning&quot;, &quot;writing&quot;
	CurrentFile    string  // File currently being processed
	ProcessedFiles int     // Files completed
	TotalFiles     int     // Total files to process (0 if unknown)
	BytesProcessed int64   // Total bytes processed
	Percentage     float64 // 0-100
}

// NEW: Error tracking
type ScanError struct {
	Path    string // File path that caused error
	Phase   string // &quot;read&quot;, &quot;parse&quot;, &quot;write&quot;
	Error   error  // The actual error
	Skipped bool   // Was the file skipped or did scan fail?
}

// NEW: Complete scan report
type ScanReport struct {
	Stats        *StreamingStats
	Errors       []ScanError
	SkippedFiles int
	WarningCount int
	Duration     string
	Success      bool
}

// NEW: Progress callback
type ProgressCallback func(progress ScanProgress)

</file>

<file path="types/output_option.go" language="go" lines="11" size="234 B" extension=".go" modified="2025-10-14 20:20:38" is_text="true">
package types

type OutputOptions struct {
	IncludeSummary       bool
	IncludeDirectoryTree bool
	ShowLineNumbers      bool
	IncludeContent       bool
	RemoveComments       bool
	RemoveEmptyLines     bool
	CompressCode         bool
}

</file>

<file path="utils/format.go" language="go" lines="96" size="1.9 KB" extension=".go" modified="2025-10-12 01:25:49" is_text="true">
package utils

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;time&quot;
)

func FormatBytes(bytes int64) string {
	const unit = 1024
	if bytes &lt; unit {
		return fmt.Sprintf(&quot;%d B&quot;, bytes)
	}
	div, exp := int64(unit), 0
	for n := bytes / unit; n &gt;= unit; n /= unit {
		div *= unit
		exp++
	}
	return fmt.Sprintf(&quot;%.1f %cB&quot;, float64(bytes)/float64(div), &quot;KMGTPE&quot;[exp])
}

func CountLines(content string) int {
	if content == &quot;&quot; {
		return 0
	}

	lines := 1
	for _, char := range content {
		if char == &#39;\n&#39; {
			lines++
		}
	}

	// file ends with newline
	if strings.HasSuffix(content, &quot;\n&quot;) {
		lines--
	}

	return lines
}

// NEW: Format duration human-readable
func FormatDuration(d time.Duration) string {
	if d &lt; time.Second {
		return fmt.Sprintf(&quot;%dms&quot;, d.Milliseconds())
	}
	if d &lt; time.Minute {
		return fmt.Sprintf(&quot;%.1fs&quot;, d.Seconds())
	}
	if d &lt; time.Hour {
		minutes := int(d.Minutes())
		seconds := int(d.Seconds()) % 60
		return fmt.Sprintf(&quot;%dh %dm&quot;, minutes, seconds)
	}
	hours := int(d.Hours())
	minutes := int(d.Minutes()) % 60
	return fmt.Sprintf(&quot;%dh %dm&quot;, hours, minutes)
}

// NEW: Create a simple progress bar
func CreateProgressBar(current, total int, width int) string {
	if total == 0 {
		return &quot;[&quot; + strings.Repeat(&quot;‚ñà&quot;, width) + &quot;]&quot;
	}

	percentage := float64(current) / float64(total)
	filled := int(percentage * float64(width))

	if filled &gt; width {
		filled = width
	}

	bar := strings.Repeat(&quot;‚ñà&quot;, filled) + strings.Repeat(&quot;‚ñë&quot;, width-filled)
	return fmt.Sprintf(&quot;[%s] %d%%&quot;, bar, int(percentage*100))
}

// NEW: Format ETA based on progress
func EstimateTimeRemaining(processed, total int, elapsed time.Duration) string {
	if processed == 0 || total == 0 {
		return &quot;calculating...&quot;
	}

	percentage := float64(processed) / float64(total)
	if percentage == 0 {
		return &quot;calculating...&quot;
	}

	totalEstimated := time.Duration(float64(elapsed) / percentage)
	remaining := totalEstimated - elapsed

	if remaining &lt; 0 {
		return &quot;finishing...&quot;
	}

	return FormatDuration((remaining))
}

</file>

<file path="utils/path.go" language="go" lines="62" size="1.2 KB" extension=".go" modified="2025-10-14 20:21:37" is_text="true">
package utils

import (
	&quot;path/filepath&quot;
	&quot;strings&quot;
	&quot;time&quot;

	&quot;github.com/NesoHQ/code-echo/codeecho-cli/types&quot;
)

func GetRelativePath(root, path string) string {
	rel, err := filepath.Rel(root, path)
	if err != nil {
		return path
	}
	return rel
}

func GenerateAutoFilename(repoPath, format string, opts types.OutputOptions) string {
	// Get project name
	projectName := filepath.Base(repoPath)
	if projectName == &quot;.&quot; || projectName == &quot;/&quot; {
		projectName = &quot;codeecho-scan&quot;
	}

	// Add timestamp for uniqueness
	timestamp := time.Now().Format(&quot;20060102-150405&quot;)

	// Determine file extension
	var ext string
	switch format {
	case &quot;json&quot;:
		ext = &quot;.json&quot;
	case &quot;markdown&quot;, &quot;md&quot;:
		ext = &quot;.md&quot;
	default:
		ext = &quot;.xml&quot;
	}

	// Build filename with processing indicators
	var suffix []string
	if opts.RemoveComments {
		suffix = append(suffix, &quot;no-comments&quot;)
	}
	if opts.RemoveEmptyLines {
		suffix = append(suffix, &quot;no-empty-lines&quot;)
	}
	if opts.CompressCode {
		suffix = append(suffix, &quot;compressed&quot;)
	}
	if !opts.IncludeContent {
		suffix = append(suffix, &quot;structure-only&quot;)
	}

	filename := projectName
	if len(suffix) &gt; 0 {
		filename += &quot;-&quot; + strings.Join(suffix, &quot;-&quot;)
	}
	filename += &quot;-&quot; + timestamp + ext

	return filename
}

</file>

</files>

<scan_statistics>
<total_files>20</total_files>
<total_size>82.7 KB</total_size>
<text_files>20</text_files>
<binary_files>0</binary_files>
</scan_statistics>
